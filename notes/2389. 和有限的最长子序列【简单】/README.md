# [2389. 和有限的最长子序列【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/2389.%20%E5%92%8C%E6%9C%89%E9%99%90%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 排序 + 前缀和](#2--s1---排序--前缀和)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/longest-subsequence-with-limited-sum/)

给你一个长度为 `n` 的整数数组 `nums`，和一个长度为 `m` 的整数数组 `queries`。

返回一个长度为 `m` 的数组 `answer`，其中 `answer[i]` 是 `nums` 中元素之和小于等于 `queries[i]` 的子序列的最大长度。

子序列是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。

---

示例 1：

```txt
输入：nums = [4,5,2,1], queries = [3,10,21]
输出：[2,3,4]

解释：
queries 对应的 answer 如下：
- 子序列 [2,1] 的和小于或等于 3。可以证明满足题目要求的子序列的最大长度是 2，所以 answer[0] = 2。
- 子序列 [4,5,1] 的和小于或等于 10。可以证明满足题目要求的子序列的最大长度是 3，所以 answer[1] = 3。
- 子序列 [4,5,2,1] 的和小于或等于 21。可以证明满足题目要求的子序列的最大长度是 4，所以 answer[2] = 4。
```

---

示例 2：

```txt
输入：nums = [2,3,4,5], queries = [1]
输出：[0]

解释：
空子序列是唯一一个满足元素和小于或等于 1 的子序列，所以 answer[0] = 0。
```

---

提示：

- `n == nums.length`
- `m == queries.length`
- `1 <= n, m <= 1000`
- `1 <= nums[i], queries[i] <= 10^6`

## 2. 🎯 s.1 - 排序 + 前缀和

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(N \log N + M \times N)$，其中 N 是 nums 的长度，M 是 queries 的长度，排序需要 $O(N \log N)$，每个查询需要 $O(N)$
- 空间复杂度：$O(N)$，前缀和数组的空间

算法思路：

- 贪心策略：要获得最长子序列，应该选择最小的元素，因此先对 nums 排序
- 计算排序后数组的前缀和，prefixSum[i] 表示前 i+1 个元素的和
- 对于每个查询，找到前缀和小于等于该查询值的最大索引，索引加 1 即为答案
- 可以通过遍历或二分查找来找到满足条件的最大索引
