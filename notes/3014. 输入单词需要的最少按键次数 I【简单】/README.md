# [3014. 输入单词需要的最少按键次数 I【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3014.%20%E8%BE%93%E5%85%A5%E5%8D%95%E8%AF%8D%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E6%8C%89%E9%94%AE%E6%AC%A1%E6%95%B0%20I%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 贪心](#2--s1---贪心)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/minimum-number-of-pushes-to-type-word-i/)

给你一个字符串 `word`，由 不同 小写英文字母组成。

电话键盘上的按键与 不同 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 `2` 对应 `["a","b","c"]`，我们需要按一次键来输入 `"a"`，按两次键来输入 `"b"`，按三次键来输入 `"c"`_。_

现在允许你将编号为 `2` 到 `9` 的按键重新映射到 不同 字母集合。每个按键可以映射到 任意数量 的字母，但每个字母 必须 恰好 映射到 一个 按键上。你需要找到输入字符串 `word` 所需的 最少 按键次数。

返回重新映射按键后输入 `word` 所需的 最少 按键次数。

下面给出了一种电话键盘上字母到按键的映射作为示例。注意 `1`，`*`，`#` 和 `0` 不 对应任何字母。

![img](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-28-21-36-10.png)

---

- 示例 1：

![img](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-28-21-36-24.png)

```txt
输入：word = "abcde"
输出：5
解释：图片中给出的重新映射方案的输入成本最小。
"a" -> 在按键 2 上按一次
"b" -> 在按键 3 上按一次
"c" -> 在按键 4 上按一次
"d" -> 在按键 5 上按一次
"e" -> 在按键 6 上按一次
总成本为 1 + 1 + 1 + 1 + 1 = 5 。
可以证明不存在其他成本更低的映射方案。
```

- 示例 2：

![img](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-28-21-36-30.png)

```txt
输入：word = "xycdefghij"
输出：12
解释：图片中给出的重新映射方案的输入成本最小。
"x" -> 在按键 2 上按一次
"y" -> 在按键 2 上按两次
"c" -> 在按键 3 上按一次
"d" -> 在按键 3 上按两次
"e" -> 在按键 4 上按一次
"f" -> 在按键 5 上按一次
"g" -> 在按键 6 上按一次
"h" -> 在按键 7 上按一次
"i" -> 在按键 8 上按一次
"j" -> 在按键 9 上按一次
总成本为 1 + 2 + 1 + 2 + 1 + 1 + 1 + 1 + 1 + 1 = 12 。
可以证明不存在其他成本更低的映射方案。
```

---

提示：

- `1 <= word.length <= 26`
- `word` 仅由小写英文字母组成。
- `word` 中的所有字母互不相同。

## 2. 🎯 s.1 - 贪心

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(n)$，其中 n 是字符串长度
- 空间复杂度：$O(1)$，只使用了常数级别的额外空间

解题思路：

- 共有 8 个按键（2-9）可用于映射字母
- 由于题目保证所有字母互不相同，我们可以贪心地将字母分配到按键上
- 前 8 个字母分别映射到 8 个按键的第一位，每个只需按 1 次
- 第 9-16 个字母映射到 8 个按键的第二位，每个需按 2 次
- 以此类推，第 i 个字母需要按 `⌊i/8⌋ + 1` 次
