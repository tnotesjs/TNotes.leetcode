# [3275. 第 K 近障碍物查询【中等】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3275.%20%E7%AC%AC%20K%20%E8%BF%91%E9%9A%9C%E7%A2%8D%E7%89%A9%E6%9F%A5%E8%AF%A2%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/k-th-nearest-obstacle-queries/)

有一个无限大的二维平面。

给你一个正整数 `k`，同时给你一个二维数组 `queries`，包含一系列查询：

- `queries[i] = [x, y]` ：在平面上坐标 `(x, y)` 处建一个障碍物，数据保证之前的查询 不会 在这个坐标处建立任何障碍物。

每次查询后，你需要找到离原点第 `k` 近 障碍物到原点的 距离。

请你返回一个整数数组 `results`，其中 `results[i]` 表示建立第 `i` 个障碍物以后，离原地第 `k` 近障碍物距离原点的距离。如果少于 `k` 个障碍物，`results[i] == -1`。

注意，一开始 没有 任何障碍物。

坐标在 `(x, y)` 处的点距离原点的距离定义为 `|x| + |y|`。

---

示例 1：

输入：queries = [[1,2],[3,4],[2,3],[-3,0]], k = 2

输出：[-1,7,5,3]

解释：

最初，不存在障碍物。

- `queries[0]` 之后，少于 2 个障碍物。
- `queries[1]` 之后， 两个障碍物距离原点的距离分别为 3 和 7。
- `queries[2]` 之后，障碍物距离原点的距离分别为 3，5 和 7。
- `queries[3]` 之后，障碍物距离原点的距离分别为 3，3，5 和 7。

---

示例 2：

输入：queries = [[5,5],[4,4],[3,3]], k = 1

输出：[10,8,6]

解释：

- `queries[0]` 之后，只有一个障碍物，距离原点距离为 10。
- `queries[1]` 之后，障碍物距离原点距离分别为 8 和 10。
- `queries[2]` 之后，障碍物距离原点的距离分别为 6， 8 和 10。

---

提示：

- `1 <= queries.length <= 2 * 10^5`
- 所有 `queries[i]` 互不相同。
- `-10^9 <= queries[i][0], queries[i][1] <= 10^9`
- `1 <= k <= 10^5`

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
