# [3275. 第 K 近障碍物查询【中等】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3275.%20%E7%AC%AC%20K%20%E8%BF%91%E9%9A%9C%E7%A2%8D%E7%89%A9%E6%9F%A5%E8%AF%A2%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/k-th-nearest-obstacle-queries/)

有一个无限大的二维平面。

给你一个正整数 `k` ，同时给你一个二维数组 `queries` ，包含一系列查询：

- `queries[i] = [x, y]` ：在平面上坐标 `(x, y)` 处建一个障碍物，数据保证之前的查询 **不会** 在这个坐标处建立任何障碍物。

每次查询后，你需要找到离原点第 `k` **近** 障碍物到原点的 **距离** 。

请你返回一个整数数组 `results` ，其中 `results[i]` 表示建立第 `i` 个障碍物以后，离原地第 `k` 近障碍物距离原点的距离。如果少于 `k` 个障碍物，`results[i] == -1` 。

**注意**，一开始 **没有** 任何障碍物。

坐标在 `(x, y)` 处的点距离原点的距离定义为 `|x| + |y|` 。

---

- **示例 1：**

**输入：** queries = [[1,2],[3,4],[2,3],[-3,0]], k = 2

**输出：** [-1,7,5,3]

**解释：**

最初，不存在障碍物。

- `queries[0]` 之后，少于 2 个障碍物。
- `queries[1]` 之后， 两个障碍物距离原点的距离分别为 3 和 7 。
- `queries[2]` 之后，障碍物距离原点的距离分别为 3 ，5 和 7 。
- `queries[3]` 之后，障碍物距离原点的距离分别为 3，3，5 和 7 。

---

- **示例 2：**

**输入：** queries = [[5,5],[4,4],[3,3]], k = 1

**输出：** [10,8,6]

**解释：**

- `queries[0]` 之后，只有一个障碍物，距离原点距离为 10 。
- `queries[1]` 之后，障碍物距离原点距离分别为 8 和 10 。
- `queries[2]` 之后，障碍物距离原点的距离分别为 6， 8 和 10 。

---

**提示：**

- `1 <= queries.length <= 2 * 10^5`
- 所有 `queries[i]` 互不相同。
- `-10^9 <= queries[i][0], queries[i][1] <= 10^9`
- `1 <= k <= 10^5`

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
