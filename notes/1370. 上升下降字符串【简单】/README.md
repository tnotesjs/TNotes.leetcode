# [1370. 上升下降字符串【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/1370.%20%E4%B8%8A%E5%8D%87%E4%B8%8B%E9%99%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 暴力解法](#2--s1---暴力解法)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/increasing-decreasing-string/)

给你一个字符串 `s`，请你根据下面的算法重新构造字符串：

1. 从 `s` 中选出最小的字符，将它接在结果字符串的后面。
2. 从 `s` 剩余字符中选出比上一个添加字符更大的最小字符，将它接在结果字符串后面。
3. 重复步骤 2，直到你没法从 `s` 中选择字符。
4. 从 `s` 中选出最大的字符，将它接在结果字符串的后面。
5. 从 `s` 剩余字符中选出比上一个添加字符更小的最大字符，将它接在结果字符串后面。
6. 重复步骤 5，直到你没法从 `s` 中选择字符。
7. 重复步骤 1 到 6，直到 `s` 中所有字符都已经被选过。

在任何一步中，如果最小或者最大字符不止一个，你可以选择其中任意一个，并将其添加到结果字符串。

请你返回将 `s` 中字符重新排序后的结果字符串。

---

示例 1：

```txt
输入：s = "aaaabbbbcccc"
输出："abccbaabccba"

解释：
第一轮的步骤 1，2，3 后，结果字符串为 result = "abc"
第一轮的步骤 4，5，6 后，结果字符串为 result = "abccba"
第一轮结束，现在 s = "aabbcc"，我们再次回到步骤 1
第二轮的步骤 1，2，3 后，结果字符串为 result = "abccbaabc"
第二轮的步骤 4，5，6 后，结果字符串为 result = "abccbaabccba"
```

---

示例 2：

```txt
输入：s = "rat"
输出："art"

解释：
单词 "rat" 在上述算法重排序以后变成 "art"
```

---

提示：

- `1 <= s.length <= 500`
- `s` 只包含小写英文字母。

## 2. 🎯 s.1 - 暴力解法

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(n)$，计数后按字母表往返扫描
- 空间复杂度：$O(\Sigma)$，计数数组占用，$\Sigma=26$

算法思路：

- 先统计 26 个小写字母频次
- 循环：从小到大扫一遍可用字母依次追加，再从大到小扫一遍；频次减到零即跳过
- 直到结果长度达到原串长度
