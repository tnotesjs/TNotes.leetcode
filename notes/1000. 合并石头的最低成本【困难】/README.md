# [1000. 合并石头的最低成本【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/1000.%20%E5%90%88%E5%B9%B6%E7%9F%B3%E5%A4%B4%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 区间 DP](#2--s1---区间-dp)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/minimum-cost-to-merge-stones/)

有 `n` 堆石头排成一排，第 `i` 堆中有 `stones[i]` 块石头。

每次移动需要将连续的 `k` 堆石头合并为一堆，而这次移动的成本为这 `k` 堆中石头的总数。

返回把所有石头合并成一堆的最低成本。如果无法合并成一堆，返回 `-1`。

---

示例 1：

```txt
输入：stones = [3,2,4,1], K = 2
输出：20

解释：
从 [3, 2, 4, 1] 开始。
合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。
合并 [4, 1]，成本为 5，剩下 [5, 5]。
合并 [5, 5]，成本为 10，剩下 [10]。
总成本 20，这是可能的最小值。
```

示例 2：

```txt
输入：stones = [3,2,4,1], K = 3
输出：-1

解释：
任何合并操作后，都会剩下 2 堆，我们无法再进行合并。
所以这项任务是不可能完成的。.
```

示例 3：

```txt
输入：stones = [3,5,1,2,6], K = 3
输出：25

解释：
从 [3, 5, 1, 2, 6] 开始。
合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。
合并 [3, 8, 6]，成本为 17，剩下 [17]。
总成本 25，这是可能的最小值。
```

---

提示：

- `n == stones.length`
- `1 <= n <= 30`
- `1 <= stones[i] <= 100`
- `2 <= k <= 30`

## 2. 🎯 s.1 - 区间 DP

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(n^3 \times k)$，其中 n 是石头堆数，需要枚举区间、堆数和分割点
- 空间复杂度：$O(n^2 \times k)$，三维 DP 数组的空间

算法思路：

- 合并可行性判断：每次合并减少 k-1 堆，从 n 堆到 1 堆需要 `(n-1) % (k-1) === 0`
- 定义状态：`dp[i][j][p]` 表示将区间 `[i, j]` 合并成 p 堆的最小成本
- 初始化：`dp[i][i][1] = 0`，单堆本身就是 1 堆，成本为 0
- 状态转移：枚举分割点 mid，将 `[i, j]` 分为 `[i, mid]` 合并成 1 堆和 `[mid+1, j]` 合并成 p-1 堆，注意 mid 步长为 k-1
- 最终合并：`dp[i][j][1] = dp[i][j][k] + sum[i, j]`，先合并成 k 堆再合并成 1 堆
