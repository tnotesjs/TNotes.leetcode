# [3518. 最小回文排列 II【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3518.%20%E6%9C%80%E5%B0%8F%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97%20II%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/smallest-palindromic-rearrangement-ii/)

给你一个 回文 字符串 `s` 和一个整数 `k`。

返回 `s` 的按字典序排列的 第 k 小 回文排列。如果不存在 `k` 个不同的回文排列，则返回空字符串。

---

注意： 产生相同回文字符串的不同重排视为相同，仅计为一次。

如果一个字符串从前往后和从后往前读都相同，那么这个字符串是一个 回文 字符串。

排列 是字符串中所有字符的重排。

如果字符串 `a` 按字典序小于字符串 `b`，则表示在第一个不同的位置，`a` 中的字符比 `b` 中的对应字符在字母表中更靠前。  
如果在前 `min(a.length, b.length)` 个字符中没有区别，则较短的字符串按字典序更小。

---

- 示例 1：

输入： s = "abba", k = 2

输出： "baab"

解释：

- `"abba"` 的两个不同的回文排列是 `"abba"` 和 `"baab"`。
- 按字典序，`"abba"` 位于 `"baab"` 之前。由于 `k = 2`，输出为 `"baab"`。

---

- 示例 2：

输入： s = "aa", k = 2

输出： ""

解释：

- 仅有一个回文排列：`"aa"`。
- 由于 `k = 2` 超过了可能的排列数，输出为空字符串。

---

- 示例 3：

输入： s = "bacab", k = 1

输出： "abcba"

解释：

- `"bacab"` 的两个不同的回文排列是 `"abcba"` 和 `"bacab"`。
- 按字典序，`"abcba"` 位于 `"bacab"` 之前。由于 `k = 1`，输出为 `"abcba"`。

---

提示：

- `1 <= s.length <= 10^4`
- `s` 由小写英文字母组成。
- 保证 `s` 是回文字符串。
- `1 <= k <= 10^6`

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
