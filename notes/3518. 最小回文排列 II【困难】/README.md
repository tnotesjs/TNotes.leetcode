# [3518. 最小回文排列 II【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3518.%20%E6%9C%80%E5%B0%8F%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97%20II%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/smallest-palindromic-rearrangement-ii/)

给你一个 **回文** 字符串 `s` 和一个整数 `k`。

返回 `s` 的按字典序排列的 **第 k 小** 回文排列。如果不存在 `k` 个不同的回文排列，则返回空字符串。

---

**注意：** 产生相同回文字符串的不同重排视为相同，仅计为一次。

如果一个字符串从前往后和从后往前读都相同，那么这个字符串是一个 **回文** 字符串。

**排列** 是字符串中所有字符的重排。

如果字符串 `a` 按字典序小于字符串 `b`，则表示在第一个不同的位置，`a` 中的字符比 `b` 中的对应字符在字母表中更靠前。  
如果在前 `min(a.length, b.length)` 个字符中没有区别，则较短的字符串按字典序更小。

---

- **示例 1：**

**输入：** s = "abba", k = 2

**输出：** "baab"

**解释：**

- `"abba"` 的两个不同的回文排列是 `"abba"` 和 `"baab"`。
- 按字典序，`"abba"` 位于 `"baab"` 之前。由于 `k = 2`，输出为 `"baab"`。

---

- **示例 2：**

**输入：** s = "aa", k = 2

**输出：** ""

**解释：**

- 仅有一个回文排列：`"aa"`。
- 由于 `k = 2` 超过了可能的排列数，输出为空字符串。

---

- **示例 3：**

**输入：** s = "bacab", k = 1

**输出：** "abcba"

**解释：**

- `"bacab"` 的两个不同的回文排列是 `"abcba"` 和 `"bacab"`。
- 按字典序，`"abcba"` 位于 `"bacab"` 之前。由于 `k = 1`，输出为 `"abcba"`。

---

**提示：**

- `1 <= s.length <= 10^4`
- `s` 由小写英文字母组成。
- 保证 `s` 是回文字符串。
- `1 <= k <= 10^6`

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
