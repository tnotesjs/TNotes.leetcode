# [3538. 合并得到最小旅行时间【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3538.%20%E5%90%88%E5%B9%B6%E5%BE%97%E5%88%B0%E6%9C%80%E5%B0%8F%E6%97%85%E8%A1%8C%E6%97%B6%E9%97%B4%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/merge-operations-for-minimum-travel-time/)

给你一个长度为 `l` 公里的直路，一个整数 `n`，一个整数 `k` 和 **两个** 长度为 `n` 的整数数组 `position` 和 `time` 。

数组 `position` 列出了路标的位置（单位：公里），并且是 **严格** 升序排列的（其中 `position[0] = 0` 且 `position[n - 1] = l`）。

每个 `time[i]` 表示从 `position[i]` 到 `position[i + 1]` 之间行驶 1 公里所需的时间（单位：分钟）。

你 **必须** 执行 **恰好** `k` 次合并操作。在一次合并中，你可以选择两个相邻的路标，下标为 `i` 和 `i + 1`（其中 `i > 0` 且 `i + 1 < n`），并且：

- 更新索引为 `i + 1` 的路标，使其时间变为 `time[i] + time[i + 1]`。
- 删除索引为 `i` 的路标。

返回经过 **恰好** `k` 次合并后从 0 到 `l` 的 **最小\*\***总\***\*旅行时间**（单位：分钟）。

---

- **示例 1:**

**输入:** l = 10, n = 4, k = 1, position = \[0,3,8,10\], time = \[5,8,3,6\]

**输出:** 62

**解释:**

- 合并下标为 1 和 2 的路标。删除下标为 1 的路标，并将下标为 2 的路标的时间更新为 `8 + 3 = 11`。
- 合并后：
  - `position` 数组：`[0, 8, 10]`
  - `time` 数组：`[5, 11, 6]`

| 路段   | 距离（公里） | 每公里时间（分钟） | 路段旅行时间（分钟） |
| ------ | ------------ | ------------------ | -------------------- |
| 0 → 8  | 8            | 5                  | 8 × 5 = 40           |
| 8 → 10 | 2            | 11                 | 2 × 11 = 22          |

- 总旅行时间：`40 + 22 = 62` ，这是执行 1 次合并后的最小时间。

---

- **示例 2:**

**输入:** l = 5, n = 5, k = 1, position = \[0,1,2,3,5\], time = \[8,3,9,3,3\]

**输出:** 34

**解释:**

- 合并下标为 1 和 2 的路标。删除下标为 1 的路标，并将下标为 2 的路标的时间更新为 `3 + 9 = 12`。
- 合并后：
  - `position` 数组：`[0, 2, 3, 5]`
  - `time` 数组：`[8, 12, 3, 3]`

| 路段  | 距离（公里） | 每公里时间（分钟） | 路段旅行时间（分钟） |
| ----- | ------------ | ------------------ | -------------------- |
| 0 → 2 | 2            | 8                  | 2 × 8 = 16           |
| 2 → 3 | 1            | 12                 | 1 × 12 = 12          |
| 3 → 5 | 2            | 3                  | 2 × 3 = 6            |

- 总旅行时间：`16 + 12 + 6 = 34` ，这是执行 1 次合并后的最小时间。

---

**提示:**

- `1 <= l <= 10^5`
- `2 <= n <= min(l + 1, 50)`
- `0 <= k <= min(n - 2, 10)`
- `position.length == n`
- `position[0] = 0` 和 `position[n - 1] = l`
- `position` 是严格升序排列的。
- `time.length == n`
- `1 <= time[i] <= 100​`
- `1 <= sum(time) <= 100`​​​​​​

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
