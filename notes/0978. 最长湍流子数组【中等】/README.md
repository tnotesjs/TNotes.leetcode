# [0978. 最长湍流子数组【中等】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/0978.%20%E6%9C%80%E9%95%BF%E6%B9%8D%E6%B5%81%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 滑动窗口](#2--s1---滑动窗口)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/longest-turbulent-subarray/)

给定一个整数数组 `arr`，返回 `arr` 的 最大湍流子数组的长度。

如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是 湍流子数组。

更正式地来说，当 `arr` 的子数组 `A[i], A[i+1], ..., A[j]` 满足仅满足下列条件时，我们称其为*湍流子数组*：

- 若 `i <= k < j` ：
  - 当 `k` 为奇数时， `A[k] > A[k+1]`，且
  - 当 `k` 为偶数时，`A[k] < A[k+1]`；
- 或 若 `i <= k < j` ：
  - 当 `k` 为偶数时，`A[k] > A[k+1]`，且
  - 当 `k` 为奇数时， `A[k] < A[k+1]`。

---

示例 1：

```txt
输入：arr = [9,4,2,10,7,8,8,1,9]
输出：5

解释：
arr[1] > arr[2] < arr[3] > arr[4] < arr[5]
```

---

示例 2：

```txt
输入：arr = [4,8,12,16]
输出：2
```

---

示例 3：

```txt
输入：arr = [100]
输出：1
```

---

提示：

- `1 <= arr.length <= 4 * 10^4`
- `0 <= arr[i] <= 10^9`

## 2. 🎯 s.1 - 滑动窗口

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(n)$，其中 n 是数组长度，只需遍历一次数组
- 空间复杂度：$O(1)$，只使用常数级别的额外空间

算法思路：

- 状态维护：用 `len` 维护当前湍流子数组的长度，`prevCmp` 记录前一个比较结果（1表示>，-1表示<，0表示=）
- 比较符号：用 `Math.sign(arr[i] - arr[i-1])` 计算当前比较结果
- 相等处理：如果相邻元素相等，湍流序列中断，重置长度为 1
- 符号翻转：如果比较符号翻转（`prevCmp + cmp === 0`），说明满足湍流条件，长度加 1
- 符号未翻转：如果比较符号未翻转，从当前位置重新开始计数，长度重置为 2（包含前一个元素和当前元素）
- 结果更新：每次迭代更新最大长度
