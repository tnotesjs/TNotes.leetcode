# [0338. 比特位计数【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/0338.%20%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 暴力解法](#2--s1---暴力解法)
- [3. 🎯 s.2 - 动态规划 - 最低有效位](#3--s2---动态规划---最低有效位)
- [4. 🎯 s.3 - 动态规划 - 最低设置位（推荐）](#4--s3---动态规划---最低设置位推荐)
- [5. 🎯 s.4 - 动态规划 - 最高有效位](#5--s4---动态规划---最高有效位)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/counting-bits/)

给你一个整数 `n` ，对于  `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

---

- **示例 1：**

```txt
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
```

- **示例 2：**

```txt
输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

---

**提示：**

- `0 <= n <= 10^5`

**进阶：**

- 很容易就能实现时间复杂度为 `O(n log n)` 的解决方案，你可以在线性时间复杂度 `O(n)` 内用一趟扫描解决此问题吗？
- 你能不使用任何内置函数解决此问题吗？（如，C++ 中的  `__builtin_popcount` ）

## 2. 🎯 s.1 - 暴力解法

::: code-group

<<< ./solutions/1/1.js [js]

:::

- **时间复杂度**：$O(n\log{n})$，每个数字需要 $O(\log{n})$ 时间计算
- **空间复杂度**：$O(1)$，不考虑输出数组

## 3. 🎯 s.2 - 动态规划 - 最低有效位

::: code-group

<<< ./solutions/2/1.js [js]

:::

- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(1)$

## 4. 🎯 s.3 - 动态规划 - 最低设置位（推荐）

::: code-group

<<< ./solutions/3/1.js [js]

:::

- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(1)$

## 5. 🎯 s.4 - 动态规划 - 最高有效位

::: code-group

<<< ./solutions/4/1.js [js]

:::

- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(1)$
