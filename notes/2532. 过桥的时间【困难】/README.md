# [2532. 过桥的时间【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/2532.%20%E8%BF%87%E6%A1%A5%E7%9A%84%E6%97%B6%E9%97%B4%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/time-to-cross-a-bridge/)

共有 `k` 位工人计划将 `n` 个箱子从右侧的（旧）仓库移动到左侧的（新）仓库。给你两个整数 `n` 和 `k`，以及一个二维整数数组 `time` ，数组的大小为 `k x 4` ，其中 `time[i] = [righti, picki, lefti, puti]` 。

一条河将两座仓库分隔，只能通过一座桥通行。旧仓库位于河的右岸，新仓库在河的左岸。开始时，所有 `k` 位工人都在桥的左侧等待。为了移动这些箱子，第 `i` 位工人（下标从 **0** 开始）可以：

- 从左岸（新仓库）跨过桥到右岸（旧仓库），用时 `righti` 分钟。
- 从旧仓库选择一个箱子，并返回到桥边，用时 `picki` 分钟。不同工人可以同时搬起所选的箱子。
- 从右岸（旧仓库）跨过桥到左岸（新仓库），用时 `lefti` 分钟。
- 将箱子放入新仓库，并返回到桥边，用时 `puti` 分钟。不同工人可以同时放下所选的箱子。

如果满足下面任一条件，则认为工人 `i` 的 **效率低于** 工人 `j` ：

- `lefti + righti > leftj + rightj`
- `lefti + righti == leftj + rightj` 且 `i > j`

工人通过桥时需要遵循以下规则：

- 同时只能有一名工人过桥。
- 当桥梁未被使用时，优先让右侧 **效率最低** 的工人（已经拿起盒子的工人）过桥。如果不是，优先让左侧 **效率最低** 的工人通过。
- 如果左侧已经派出足够的工人来拾取所有剩余的箱子，则 **不会** 再从左侧派出工人。

请你返回最后一个箱子 **到达桥左侧** 的时间。

---

- **示例 1：**

```txt
输入：n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]
输出：6

解释：

从 0 到 1 分钟：工人 2 通过桥到达右侧。
从 1 到 2 分钟：工人 2 从右侧仓库拿起箱子。
从 2 到 6 分钟：工人 2 通过桥到达左侧。
从 6 到 7 分钟：工人 2 向左侧仓库放下箱子。
整个过程在 7 分钟后结束。我们返回 6 因为该问题要求的是最后一名工人到达桥梁左侧的时间。
```

**示例  2：**

```txt
输入：n = 3, k = 2, time = [[1txt,5,1,8],[10,10,10,10]]
输出：37

解释：
最后一个盒子在37秒时到达左侧。请注意，我们并 没有 放下最后一个箱子，因为那样会花费更多时间，而且它们已经和工人们一起在左边。
```

---

**提示：**

- `1 <= n, k <= 10^4`
- `time.length == k`
- `time[i].length == 4`
- `1 <= lefti, picki, righti, puti <= 1000`

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
