# [1700. 无法吃午餐的学生数量【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/1700.%20%E6%97%A0%E6%B3%95%E5%90%83%E5%8D%88%E9%A4%90%E7%9A%84%E5%AD%A6%E7%94%9F%E6%95%B0%E9%87%8F%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 计数匹配](#2--s1---计数匹配)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch/)

学校的自助午餐提供圆形和方形的三明治，分别用数字 `0` 和 `1` 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。  
餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮：

- 如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。
- 否则，这名学生会 放弃这个三明治 并回到队列的尾部。

这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。

给你两个整数数组 `students` 和 `sandwiches` ，其中 `sandwiches[i]` 是栈里面第 `i^​​​​​​` 个三明治的类型（`i = 0` 是栈的顶部）， `students[j]` 是初始队列里第 `j^​​​​​​` 名学生对三明治的喜好（`j = 0` 是队列的最开始位置）。请你返回无法吃午餐的学生数量。

---

示例 1：

```txt
输入：students = [1,1,0,0], sandwiches = [0,1,0,1]
输出：0
```

解释：

- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 `students = [1,0,0,1]`。
- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 `students = [0,0,1,1]`。
- 最前面的学生拿走最顶上的三明治，剩余学生队列为 `students = [0,1,1]`，三明治栈为 `sandwiches = [1,0,1]`。
- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 `students = [1,1,0]`。
- 最前面的学生拿走最顶上的三明治，剩余学生队列为 `students = [1,0]`，三明治栈为 `sandwiches = [0,1]`。
- 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 `students = [0,1]`。
- 最前面的学生拿走最顶上的三明治，剩余学生队列为 `students = [1]`，三明治栈为 `sandwiches = [1]`。
- 最前面的学生拿走最顶上的三明治，剩余学生队列为 `students = []`，三明治栈为 `sandwiches = []`。所以所有学生都有三明治吃。

---

示例 2：

```txt
输入：students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
输出：3
```

---

提示：

- `1 <= students.length, sandwiches.length <= 100`
- `students.length == sandwiches.length`
- `sandwiches[i]` 要么是 `0` ，要么是 `1`。
- `students[i]` 要么是 `0` ，要么是 `1`。

## 2. 🎯 s.1 - 计数匹配

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(N)$，单次遍历
- 空间复杂度：$O(1)$，常数计数

解题思路：

- 统计学生中 0/1 数量，顺序遍历三明治栈，若当前三明治所需数量仍有剩则消耗一个，否则后续都无法匹配，返回剩余学生数（仍未消耗的计数之和）。
