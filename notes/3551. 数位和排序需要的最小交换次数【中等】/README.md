# [3551. 数位和排序需要的最小交换次数【中等】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3551.%20%E6%95%B0%E4%BD%8D%E5%92%8C%E6%8E%92%E5%BA%8F%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/minimum-swaps-to-sort-by-digit-sum/)

给你一个由 **互不相同** 的正整数组成的数组 `nums`，需要根据每个数字的数位和（即每一位数字相加求和）按 **升序** 对数组进行排序。如果两个数字的数位和相等，则较小的数字排在前面。

返回将 `nums` 排列为上述排序顺序所需的 **最小** 交换次数。

一次 **交换** 定义为交换数组中两个不同位置的值。

---

- **示例 1：**

**输入:** nums = [37,100]

**输出:** 1

**解释:**

- 计算每个整数的数位和：`[3 + 7 = 10, 1 + 0 + 0 = 1] → [10, 1]`
- 根据数位和排序：`[100, 37]`。将 `37` 与 `100` 交换，得到排序后的数组。
- 因此，将 `nums` 排列为排序顺序所需的最小交换次数为 1。

---

- **示例 2：**

**输入:** nums = [22,14,33,7]

**输出:** 0

**解释:**

- 计算每个整数的数位和：`[2 + 2 = 4, 1 + 4 = 5, 3 + 3 = 6, 7 = 7] → [4, 5, 6, 7]`
- 根据数位和排序：`[22, 14, 33, 7]`。数组已经是排序好的。
- 因此，将 `nums` 排列为排序顺序所需的最小交换次数为 0。

---

- **示例 3：**

**输入:** nums = [18,43,34,16]

**输出:** 2

**解释:**

- 计算每个整数的数位和：`[1 + 8 = 9, 4 + 3 = 7, 3 + 4 = 7, 1 + 6 = 7] → [9, 7, 7, 7]`
- 根据数位和排序：`[16, 34, 43, 18]`。将 `18` 与 `16` 交换，再将 `43` 与 `34` 交换，得到排序后的数组。
- 因此，将 `nums` 排列为排序顺序所需的最小交换次数为 2。

---

**提示:**

- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^9`
- `nums` 由 **互不相同** 的正整数组成。

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
