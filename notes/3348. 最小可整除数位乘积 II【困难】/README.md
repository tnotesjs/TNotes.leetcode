# [3348. 最小可整除数位乘积 II【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3348.%20%E6%9C%80%E5%B0%8F%E5%8F%AF%E6%95%B4%E9%99%A4%E6%95%B0%E4%BD%8D%E4%B9%98%E7%A7%AF%20II%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/smallest-divisible-digit-product-ii/)

给你一个字符串 `num` ，表示一个 **正** 整数，同时给你一个整数 `t` 。

如果一个整数 **没有** 任何数位是 0 ，那么我们称这个整数是 **无零** 数字。

请你返回一个字符串，这个字符串对应的整数是大于等于 `num` 的 **最小无零** 整数，且 **各数位之积** 能被 `t` 整除。如果不存在这样的数字，请你返回 `"-1"` 。

---

- **示例 1：**

**输入：** num = "1234", t = 256

**输出：** "1488"

**解释：**

大于等于 1234 且能被 256 整除的最小无零整数是 1488 ，它的数位乘积为 256 。

---

- **示例 2：**

**输入：** num = "12355", t = 50

**输出：** "12355"

**解释：**

12355 已经是无零且数位乘积能被 50 整除的整数，它的数位乘积为 150 。

---

- **示例 3：**

**输入：** num = "11111", t = 26

**输出：** "-1"

**解释：**

不存在大于等于 11111 且数位乘积能被 26 整除的整数。

---

**提示：**

- `2 <= num.length <= 2 * 10^5`
- `num` 只包含 `['0', '9']` 之间的数字。
- `num` 不包含前导 0 。
- `1 <= t <= 10^14`

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
