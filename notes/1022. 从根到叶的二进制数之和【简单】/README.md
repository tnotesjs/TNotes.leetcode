# [1022. 从根到叶的二进制数之和【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/1022.%20%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E5%92%8C%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - DFS](#2--s1---dfs)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/)

给出一棵二叉树，其上每个结点的值都是 `0` 或 `1`。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。

- 例如，如果路径为 `0 -> 1 -> 1 -> 0 -> 1`，那么它表示二进制数 `01101`，也就是 `13`。

对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。

返回这些数字之和。题目数据保证答案是一个 32 位整数。

---

示例 1：

![img](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-17-15-19-20.png)

```txt
输入：root = [1,0,1,0,1,0,1]
输出：22

解释：
(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
```

示例 2：

```txt
输入：root = [0]
输出：0
```

---

提示：

- 树中的节点数在 `[1, 1000]` 范围内
- `Node.val` 仅为 `0` 或 `1`

## 2. 🎯 s.1 - DFS

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(n)$，其中 n 是二叉树的节点数，每个节点访问一次
- 空间复杂度：$O(h)$，其中 h 是树的高度，递归调用栈的最大深度

解题思路：

- 使用深度优先搜索（DFS）遍历从根到叶的所有路径
- 遍历过程中维护当前路径的二进制值：`cur = (acc << 1) + node.val`
  - `acc << 1` 等价于 `acc * 2`，相当于二进制左移一位
  - 加上当前节点值 `node.val`（0 或 1）
- 当到达叶子节点（无左右子节点）时，将当前路径值累加到总和
- 递归遍历左右子树，最终返回所有路径值的总和
