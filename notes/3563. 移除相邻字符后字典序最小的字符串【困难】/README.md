# [3563. 移除相邻字符后字典序最小的字符串【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3563.%20%E7%A7%BB%E9%99%A4%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6%E5%90%8E%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/lexicographically-smallest-string-after-adjacent-removals/)

给你一个由小写英文字母组成的字符串 `s`。

你可以进行以下操作任意次（包括零次）：

- 移除字符串中 **任意** 一对 **相邻** 字符，这两个字符在字母表中是 **连续** 的，无论顺序如何（例如，`'a'` 和 `'b'`，或者 `'b'` 和 `'a'`）。
- 将剩余字符左移以填补空隙。

返回经过最优操作后可以获得的 **字典序最小** 的字符串。

当且仅当在第一个不同的位置上，字符串 `a` 的字母在字母表中出现的位置早于字符串 `b` 的字母，则认为字符串 `a` 的 **字典序小于** 字符串 `b`，。  
如果 `min(a.length, b.length)` 个字符都相同，则较短的字符串字典序更小。

---

**注意：** 字母表被视为循环的，因此 `'a'` 和 `'z'` 也视为连续。

---

- **示例 1：**

**输入：** s = "abc"

**输出：** "a"

**解释：**

- 从字符串中移除 `"bc"`，剩下 `"a"`。
- 无法进行更多操作。因此，经过所有可能的移除后，字典序最小的字符串是 `"a"`。

---

- **示例 2：**

**输入：** s = "bcda"

**输出：** ""

**解释：**

- 从字符串中移除 `"cd"`，剩下 `"ba"`。
- 从字符串中移除 `"ba"`，剩下 `""`。
- 无法进行更多操作。因此，经过所有可能的移除后，字典序最小的字符串是 `""`。

---

- **示例 3：**

**输入：** s = "zdce"

**输出：** "zdce"

**解释：**

- 从字符串中移除 `"dc"`，剩下 `"ze"`。
- 无法对 `"ze"` 进行更多操作。
- 然而，由于 `"zdce"` 的字典序小于 `"ze"`。因此，经过所有可能的移除后，字典序最小的字符串是 `"zdce"`。

---

**提示：**

- `1 <= s.length <= 250`
- `s` 仅由小写英文字母组成。

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
