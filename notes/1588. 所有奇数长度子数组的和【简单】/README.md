# [1588. 所有奇数长度子数组的和【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/1588.%20%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 贡献计数](#2--s1---贡献计数)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/sum-of-all-odd-length-subarrays/)

给你一个正整数数组 `arr` ，请你计算所有可能的奇数长度子数组的和。

子数组 定义为原数组中的一个连续子序列。

请你返回 `arr` 中 所有奇数长度子数组的和。

---

示例 1：

```txt
输入：arr = [1,4,2,5,3]
输出：58
解释：所有奇数长度子数组和它们的和为：
[1] = 1
[4] = 4
[2] = 2
[5] = 5
[3] = 3
[1,4,2] = 7
[4,2,5] = 11
[2,5,3] = 10
[1,4,2,5,3] = 15
我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58
```

示例 2：

```txt
输入：arr = [1,2]
输出：3
解释：总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3。
```

示例 3：

```txt
输入：arr = [10,11,12]
输出：66
```

---

提示：

- `1 <= arr.length <= 100`
- `1 <= arr[i] <= 1000`

---

进阶：

你可以设计一个 O(n) 时间复杂度的算法解决此问题吗？

## 2. 🎯 s.1 - 贡献计数

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(N)$，单次遍历计算贡献
- 空间复杂度：$O(1)$，常数变量

解题思路：

- 计算每个元素作为子数组成员出现的次数：左侧可选长度 `(i + 1)`，右侧可选长度 `(n - i)`，总组合为乘积，其中奇数长度贡献是奇数乘积对 2 取整：`((i+1)*(n-i)+1)//2`。将元素值乘以其奇数出现次数累加即可。
