# [2914. 使二进制字符串变美丽的最少修改次数【中等】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/2914.%20%E4%BD%BF%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E7%BE%8E%E4%B8%BD%E7%9A%84%E6%9C%80%E5%B0%91%E4%BF%AE%E6%94%B9%E6%AC%A1%E6%95%B0%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/minimum-number-of-changes-to-make-binary-string-beautiful/)

给你一个长度为偶数下标从 **0** 开始的二进制字符串 `s` 。

如果可以将一个字符串分割成一个或者更多满足以下条件的子字符串，那么我们称这个字符串是 **美丽的** ：

- 每个子字符串的长度都是 **偶数** 。
- 每个子字符串都 **只** 包含 `1` 或 **只** 包含 `0` 。

你可以将 `s` 中任一字符改成 `0` 或者 `1` 。

请你返回让字符串 `s` 美丽的 **最少** 字符修改次数。

---

- **示例 1：**

```txt
输入：s = "1001"
输出：2
解释：我们将 s[1] 改为 1 ，且将 s[3] 改为 0 ，得到字符串 "1100" 。
字符串 "1100" 是美丽的，因为我们可以将它分割成 "11|00" 。
将字符串变美丽最少需要 2 次修改。
```

- **示例 2：**

```txt
输入：s = "10"
输出：1
解释：我们将 s[1] 改为 1 ，得到字符串 "11" 。
字符串 "11" 是美丽的，因为它已经是美丽的。
将字符串变美丽最少需要 1 次修改。
```

- **示例 3：**

```txt
输入：s = "0000"
输出：0
解释：不需要进行任何修改，字符串 "0000" 已经是美丽字符串。
```

---

**提示：**

- `2 <= s.length <= 10^5`
- `s` 的长度为偶数。
- `s[i]` 要么是 `'0'` ，要么是 `'1'` 。

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
