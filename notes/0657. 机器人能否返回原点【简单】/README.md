# [0657. 机器人能否返回原点【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/0657.%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%83%BD%E5%90%A6%E8%BF%94%E5%9B%9E%E5%8E%9F%E7%82%B9%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 暴力解法](#2--s1---暴力解法)
- [3. 🎯 s.2 - 正则](#3--s2---正则)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/robot-return-to-origin/)

在二维平面上，有一个机器人从原点 `(0, 0)` 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 **`(0, 0)` 处结束**。

移动顺序由字符串 `moves` 表示。字符 `move[i]` 表示其第 `i` 次移动。机器人的有效动作有 `R`（右），`L`（左），`U`（上）和 `D`（下）。

如果机器人在完成所有动作后返回原点，则返回 `true`。否则，返回 `false`。

**注意：** 机器人“面朝”的方向无关紧要。 `“R”` 将始终使机器人向右移动一次，`“L”` 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。

- **示例 1:**

```txt
输入: moves = "UD"
输出: true

解释：
机器人向上移动一次，然后向下移动一次。
所有动作都具有相同的幅度，因此它最终回到它开始的原点。
因此，我们返回 true。
```

- **示例 2:**

```txt
输入: moves = "LL"
输出: false

解释：
机器人向左移动两次。
它最终位于原点的左侧，距原点有两次 “移动” 的距离。
我们返回 false，因为它在移动结束时没有返回原点。
```

---

**提示:**

- `1 <= moves.length <= 2 * 10^4`
- `moves` 只包含字符 `'U'`, `'D'`, `'L'` 和 `'R'`

## 2. 🎯 s.1 - 暴力解法

::: code-group

<<< ./solutions/1/1.js [js]

:::

- **时间复杂度**：$O(n)$，其中 n 是移动指令字符串的长度，需要遍历每个字符一次
- **空间复杂度**：$O(1)$，只使用了常数个额外变量来记录坐标位置

## 3. 🎯 s.2 - 正则

::: code-group

<<< ./solutions/2/1.js [js]

:::

- **时间复杂度**：$O(n)$，其中 n 是 `moves` 字符串的长度
- **空间复杂度**：$O(n)$，主要由正则匹配过程中的中间数组占用空间决定
  - 相比暴力解法，这种方法虽然时间复杂度相同，但空间复杂度更高，因为它需要为每次匹配创建完整的匹配结果数组。
