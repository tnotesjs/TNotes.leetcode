# [2780. 合法分割的最小下标【中等】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/2780.%20%E5%90%88%E6%B3%95%E5%88%86%E5%89%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E4%B8%8B%E6%A0%87%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/minimum-index-of-a-valid-split/)

如果在长度为 `m` 的整数数组 `arr` 中 **超过一半** 的元素值为 `x`，那么我们称 `x` 是 **支配元素** 。

给你一个下标从 **0** 开始长度为 `n` 的整数数组 `nums` ，数据保证它含有一个 **支配** 元素。

你需要在下标 `i` 处将 `nums` 分割成两个数组 `nums[0, ..., i]` 和 `nums[i + 1, ..., n - 1]` ，如果一个分割满足以下条件，我们称它是 **合法** 的：

- `0 <= i < n - 1`
- `nums[0, ..., i]` 和 `nums[i + 1, ..., n - 1]` 的支配元素相同。

这里， `nums[i, ..., j]` 表示 `nums` 的一个子数组，它开始于下标 `i` ，结束于下标 `j` ，两个端点都包含在子数组内。特别地，如果 `j < i` ，那么 `nums[i, ..., j]` 表示一个空数组。

请你返回一个 **合法分割** 的 **最小** 下标。如果合法分割不存在，返回 `-1` 。

---

- **示例 1：**

```txt
输入：nums = [1,2,2,2]
输出：2
解释：我们将数组在下标 2 处分割，得到 [1,2,2] 和 [2] 。
数组 [1,2,2] 中，元素 2 是支配元素，因为它在数组中出现了 2 次，且 2 * 2 > 3 。
数组 [2] 中，元素 2 是支配元素，因为它在数组中出现了 1 次，且 1 * 2 > 1 。
两个数组 [1,2,2] 和 [2] 都有与 nums 一样的支配元素，所以这是一个合法分割。
下标 2 是合法分割中的最小下标。
```

- **示例 2：**

```txt
输入：nums = [2,1,3,1,1,1,7,1,2,1]
输出：4
解释：我们将数组在下标 4 处分割，得到 [2,1,3,1,1] 和 [1,7,1,2,1] 。
数组 [2,1,3,1,1] 中，元素 1 是支配元素，因为它在数组中出现了 3 次，且 3 * 2 > 5 。
数组 [1,7,1,2,1] 中，元素 1 是支配元素，因为它在数组中出现了 3 次，且 3 * 2 > 5 。
两个数组 [2,1,3,1,1] 和 [1,7,1,2,1] 都有与 nums 一样的支配元素，所以这是一个合法分割。
下标 4 是所有合法分割中的最小下标。
```

- **示例 3：**

```txt
输入：nums = [3,3,3,3,7,2,2]
输出：-1
解释：没有合法分割。
```

---

**提示：**

- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^9`
- `nums` 有且只有一个支配元素。

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
