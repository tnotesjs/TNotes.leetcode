# [1047. 删除字符串中的所有相邻重复项【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/1047.%20%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 栈](#2--s1---栈)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

给出由小写字母组成的字符串 `s`，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 `s` 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

---

示例：

```txt
输入："abbaca"
输出："ca"
```

解释：

例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。

之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。

---

提示：

1. `1 <= s.length <= 10^5`
2. `s` 仅由小写英文字母组成。

## 2. 🎯 s.1 - 栈

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(n)$，其中 $n$ 为字符串长度，只需遍历一次字符串
- 空间复杂度：$O(n)$，用于存储栈中的字符以构建最终结果

算法思路：

- 维护一个栈用于存储遍历过的字符
- 遍历字符串，若当前字符与栈顶字符相同，则说明出现了相邻重复项，将栈顶弹出
- 若当前字符与栈顶不同或栈为空，则将当前字符压入栈中
- 最终栈中留下的字符即为删除所有相邻重复项后的结果
