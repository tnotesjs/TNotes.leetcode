# [3499. 操作后最大活跃区段数 I【中等】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3499.%20%E6%93%8D%E4%BD%9C%E5%90%8E%E6%9C%80%E5%A4%A7%E6%B4%BB%E8%B7%83%E5%8C%BA%E6%AE%B5%E6%95%B0%20I%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/maximize-active-section-with-trade-i/)

给你一个长度为 `n` 的二进制字符串 `s`，其中：

- `'1'` 表示一个 **活跃** 区段。
- `'0'` 表示一个 **非活跃** 区段。

你可以执行 **最多一次操作** 来最大化 `s` 中的活跃区段数量。在一次操作中，你可以：

- 将一个被 `'0'` 包围的连续 `'1'` 区块转换为全 `'0'`。
- 然后，将一个被 `'1'` 包围的连续 `'0'` 区块转换为全 `'1'`。

返回在执行最优操作后，`s` 中的 **最大** 活跃区段数。

---

**注意：** 处理时需要在 `s` 的两侧加上 `'1'` ，即 `t = '1' + s + '1'`。这些加上的 `'1'` 不会影响最终的计数。

---

- **示例 1：**

**输入：** s = "01"

**输出：** 1

**解释：**

因为没有被 `'0'` 包围的 `'1'` 区块，因此无法进行有效操作。最大活跃区段数为 1。

---

- **示例 2：**

**输入：** s = "0100"

**输出：** 4

**解释：**

- 字符串 `"0100"` → 两端加上 `'1'` 后得到 `"101001"` 。
- 选择 `"0100"`，`"10**1**001"` → `"1**0000**1"` → `"1**1111**1"` 。
- 最终的字符串去掉两端的 `'1'` 后为 `"1111"` 。最大活跃区段数为 4。

---

- **示例 3：**

**输入：** s = "1000100"

**输出：** 7

**解释：**

- 字符串 `"1000100"` → 两端加上 `'1'` 后得到 `"110001001"` 。
- 选择 `"000100"`，`"11000**1**001"` → `"11**000000**1"` → `"11**111111**1"`。
- 最终的字符串去掉两端的 `'1'` 后为 `"1111111"`。最大活跃区段数为 7。

---

- **示例 4：**

**输入：** s = "01010"

**输出：** 4

**解释：**

- 字符串 `"01010"` → 两端加上 `'1'` 后得到 `"1010101"`。
- 选择 `"010"`，`"10**1**0101"` → `"1**000**101"` → `"1**111**101"`。
- 最终的字符串去掉两端的 `'1'` 后为 `"11110"`。最大活跃区段数为 4。

---

**提示：**

- `1 <= n == s.length <= 10^5`
- `s[i]` 仅包含 `'0'` 或 `'1'`

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
