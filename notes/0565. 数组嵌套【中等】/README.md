# [0565. 数组嵌套【中等】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/0565.%20%E6%95%B0%E7%BB%84%E5%B5%8C%E5%A5%97%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 暴力解法](#2--s1---暴力解法)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/array-nesting/)

索引从`0`开始长度为`N`的数组`A`，包含`0`到`N - 1`的所有整数。找到最大的集合`S`并返回其大小，其中 `S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }`且遵守以下的规则。

假设选择索引为 `i` 的元素 `A[i]` 为 `S` 的第一个元素，`S` 的下一个元素应该是 `A[A[i]]`，之后是 `A[A[A[i]]]...` 以此类推，不断添加直到 `S` 出现重复的元素。

示例 1：

```txt
输入: A = [5,4,0,3,1,6,2]
输出: 4
解释:
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

其中一种最长的 S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}
```

---

提示：

- `1 <= nums.length <= 10^5`
- `0 <= nums[i] < nums.length`
- `A`中不含有重复的元素。

## 2. 🎯 s.1 - 暴力解法

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
