# [1299. 将每个元素替换为右侧最大元素【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/1299.%20%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%B3%E4%BE%A7%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 逆向维护最大值](#2--s1---逆向维护最大值)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/replace-elements-with-greatest-element-on-right-side/)

给你一个数组 `arr`，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 `-1` 替换。

完成所有替换操作后，请你返回这个数组。

---

示例 1：

```txt
输入：arr = [17,18,5,4,6,1]
输出：[18,6,6,6,1,-1]
```

解释：

- 下标 0 的元素 --> 右侧最大元素是下标 1 的元素 (18)
- 下标 1 的元素 --> 右侧最大元素是下标 4 的元素 (6)
- 下标 2 的元素 --> 右侧最大元素是下标 4 的元素 (6)
- 下标 3 的元素 --> 右侧最大元素是下标 4 的元素 (6)
- 下标 4 的元素 --> 右侧最大元素是下标 5 的元素 (1)
- 下标 5 的元素 --> 右侧没有其他元素，替换为 -1

---

示例 2：

```txt
输入：arr = [400]
输出：[-1]
```

解释：下标 0 的元素右侧没有其他元素。

---

提示：

- `1 <= arr.length <= 10^4`
- `1 <= arr[i] <= 10^5`

## 2. 🎯 s.1 - 逆向维护最大值

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(N)$，单次逆向扫描
- 空间复杂度：$O(1)$，就地替换仅常数变量

算法思路：

- 从右向左遍历，维护右侧当前最大值 `mx`
- 每个位置先暂存原值，再用 `mx` 替换，随后更新 `mx = max(mx, 原值)`
