# [0541. 反转字符串 II【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/0541.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%20II%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 暴力解法](#2--s1---暴力解法)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/reverse-string-ii/)

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

---

示例 1：

```txt
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

示例 2：

```txt
输入：s = "abcd", k = 2
输出："bacd"
```

---

提示：

- `1 <= s.length <= 10^4`
- `s` 仅由小写英文组成
- `1 <= k <= 10^4`

## 2. 🎯 s.1 - 暴力解法

::: code-group

<<< ./solutions/1/1.js [js-1]

<<< ./solutions/1/2.js [js-2]

:::

- 时间复杂度：$O(n)$，其中 $n$ 是字符串的长度，需要遍历每个字符一次
- 空间复杂度：$O(n)$，需要额外的数组存储字符
- 解题思路：
  1. 分组处理：每 2k 个字符为一组进行处理
  2. 按规则反转：
     - 反转每组的前 k 个字符
     - 如果剩余字符不足 k 个，全部反转
     - 如果剩余字符在 `[k, 2k)` 范围内，只反转前 k 个
  3. 拼接结果：将处理后的各段拼接成最终结果
- `js-2` 采用的是切片的实现方式，解题思路跟 `js-1` 是一样的。
- 执行过程示例：

::: code-group

```txt [示例 1]
示例 1：
输入：s = "abcdefg", k = 2
输出："bacdfeg"

n = 7, k = 2, 2k = 4

处理过程：
i = 0: 处理 [0, 3] 范围
  - 反转前 k=2 个字符 [0, 1]： "ab" -> "ba"
  - 结果："bacd" + "efg"

i = 4: 处理 [4, 6] 范围（剩余3个字符）
  - 反转前 k=2 个字符 [4, 5]： "ef" -> "fe"
  - 结果："bacd" + "feg" = "bacdfeg"
```

```txt [示例 2]
示例 2：
输入：s = "abcd", k = 2
输出："bacd"

n = 4, k = 2, 2k = 4

处理过程：
i = 0: 处理 [0, 3] 范围（正好2k个字符）
  - 反转前 k=2 个字符 [0, 1]： "ab" -> "ba"
  - 剩余字符 "cd" 保持不变
  - 结果："bacd"
```

:::
