# [2218. 从栈中取出 K 个硬币的最大面值和【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/2218.%20%E4%BB%8E%E6%A0%88%E4%B8%AD%E5%8F%96%E5%87%BA%20K%20%E4%B8%AA%E7%A1%AC%E5%B8%81%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E5%80%BC%E5%92%8C%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/)

一张桌子上总共有 `n` 个硬币 栈。每个栈有 正整数 个带面值的硬币。

每一次操作中，你可以从任意一个栈的 顶部 取出 1 个硬币，从栈中移除它，并放入你的钱包里。

给你一个列表 `piles` ，其中 `piles[i]` 是一个整数数组，分别表示第 `i` 个栈里 从顶到底 的硬币面值。同时给你一个正整数 `k` ，请你返回在 恰好 进行 `k` 次操作的前提下，你钱包里硬币面值之和 最大为多少。

---

示例 1：

![img](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-27-10-31-21.png)

```txt
输入：piles = [[1,100,3],[7,8,9]], k = 2
输出：101
解释：
上图展示了几种选择 k 个硬币的不同方法。
我们可以得到的最大面值为 101。
```

示例 2：

```txt
输入：piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7
输出：706
解释：
如果我们所有硬币都从最后一个栈中取，可以得到最大面值和。
```

---

提示：

- `n == piles.length`
- `1 <= n <= 1000`
- `1 <= piles[i][j] <= 10^5`
- `1 <= k <= sum(piles[i].length) <= 2000`

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
