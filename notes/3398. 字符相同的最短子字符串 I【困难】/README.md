# [3398. 字符相同的最短子字符串 I【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3398.%20%E5%AD%97%E7%AC%A6%E7%9B%B8%E5%90%8C%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%20I%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/smallest-substring-with-identical-characters-i/)

给你一个长度为 `n` 的二进制字符串 `s` 和一个整数 `numOps`。

你可以对 `s` 执行以下操作，**最多** `numOps` 次：

- 选择任意下标 `i`（其中 `0 <= i < n`），并 **翻转** `s[i]`，即如果 `s[i] == '1'`，则将 `s[i]` 改为 `'0'`，反之亦然。

你需要 **最小化** `s` 的最长 **相同 子字符串** 的长度，**相同子字符串** 是指子字符串中的所有字符都 **相同**。

> - 子字符串 是字符串中连续的 非空 字符序列。

返回执行所有操作后可获得的 **最小** 长度。

---

- **示例 1：**

**输入:** s = "000001", numOps = 1

**输出:** 2

**解释:**

将 `s[2]` 改为 `'1'`，`s` 变为 `"001001"`。最长的所有字符相同的子串为 `s[0..1]` 和 `s[3..4]`。

---

- **示例 2：**

**输入:** s = "0000", numOps = 2

**输出:** 1

**解释:**

将 `s[0]` 和 `s[2]` 改为 `'1'`，`s` 变为 `"1010"`。

---

- **示例 3：**

**输入:** s = "0101", numOps = 0

**输出:** 1

---

**提示：**

- `1 <= n == s.length <= 1000`
- `s` 仅由 `'0'` 和 `'1'` 组成。
- `0 <= numOps <= n`

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
