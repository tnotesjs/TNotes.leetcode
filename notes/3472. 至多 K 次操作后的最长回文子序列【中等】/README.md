# [3472. 至多 K 次操作后的最长回文子序列【中等】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3472.%20%E8%87%B3%E5%A4%9A%20K%20%E6%AC%A1%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/longest-palindromic-subsequence-after-at-most-k-operations/)

给你一个字符串 `s` 和一个整数 `k`。

在一次操作中，你可以将任意位置的字符替换为字母表中相邻的字符（字母表是循环的，因此 `'z'` 的下一个字母是 `'a'`）。例如，将 `'a'` 替换为下一个字母结果是 `'b'`，将 `'a'` 替换为上一个字母结果是 `'z'`；同样，将 `'z'` 替换为下一个字母结果是 `'a'`，替换为上一个字母结果是 `'y'`。

返回在进行 最多 `k` 次操作后，`s` 的 最长回文子序列 的长度。

子序列 是一个 非空 字符串，可以通过删除原字符串中的某些字符（或不删除任何字符）并保持剩余字符的相对顺序得到。

回文 是正着读和反着读都相同的字符串。

---

- 示例 1：

输入: s = "abced", k = 2

输出: 3

解释:

- 将 `s[1]` 替换为下一个字母，得到 `"acced"`。
- 将 `s[4]` 替换为上一个字母，得到 `"accec"`。

子序列 `"ccc"` 形成一个长度为 3 的回文，这是最长的回文子序列。

---

- 示例 2：

输入: s = "aaazzz", k = 4

输出: 6

解释:

- 将 `s[0]` 替换为上一个字母，得到 `"zaazzz"`。
- 将 `s[4]` 替换为下一个字母，得到 `"zaazaz"`。
- 将 `s[3]` 替换为下一个字母，得到 `"zaaaaz"`。

整个字符串形成一个长度为 6 的回文。

---

提示：

- `1 <= s.length <= 200`
- `1 <= k <= 200`
- `s` 仅由小写英文字母组成。

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
