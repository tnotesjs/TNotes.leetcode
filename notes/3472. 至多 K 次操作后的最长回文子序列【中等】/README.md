# [3472. 至多 K 次操作后的最长回文子序列【中等】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3472.%20%E8%87%B3%E5%A4%9A%20K%20%E6%AC%A1%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/longest-palindromic-subsequence-after-at-most-k-operations/)

给你一个字符串 `s` 和一个整数 `k`。

在一次操作中，你可以将任意位置的字符替换为字母表中相邻的字符（字母表是循环的，因此 `'z'` 的下一个字母是 `'a'`）。例如，将 `'a'` 替换为下一个字母结果是 `'b'`，将 `'a'` 替换为上一个字母结果是 `'z'`；同样，将 `'z'` 替换为下一个字母结果是 `'a'`，替换为上一个字母结果是 `'y'`。

返回在进行 **最多** `k` 次操作后，`s` 的 **最长回文子序列** 的长度。

**子序列** 是一个 **非空** 字符串，可以通过删除原字符串中的某些字符（或不删除任何字符）并保持剩余字符的相对顺序得到。

**回文** 是正着读和反着读都相同的字符串。

---

- **示例 1：**

**输入:** s = "abced", k = 2

**输出:** 3

**解释:**

- 将 `s[1]` 替换为下一个字母，得到 `"acced"`。
- 将 `s[4]` 替换为上一个字母，得到 `"accec"`。

子序列 `"ccc"` 形成一个长度为 3 的回文，这是最长的回文子序列。

---

- **示例 2：**

**输入:** s = "aaazzz", k = 4

**输出:** 6

**解释:**

- 将 `s[0]` 替换为上一个字母，得到 `"zaazzz"`。
- 将 `s[4]` 替换为下一个字母，得到 `"zaazaz"`。
- 将 `s[3]` 替换为下一个字母，得到 `"zaaaaz"`。

整个字符串形成一个长度为 6 的回文。

---

**提示:**

- `1 <= s.length <= 200`
- `1 <= k <= 200`
- `s` 仅由小写英文字母组成。

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
