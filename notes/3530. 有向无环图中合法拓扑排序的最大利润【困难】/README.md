# [3530. 有向无环图中合法拓扑排序的最大利润【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3530.%20%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E4%B8%AD%E5%90%88%E6%B3%95%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/maximum-profit-from-valid-topological-order-in-dag/)

给你一个由 `n` 个节点组成的**有向无环图（DAG）**，节点编号从 `0` 到 `n - 1`，通过二维数组 `edges` 表示，其中 `edges[i] = [ui, vi]` 表示一条从节点 `ui` 指向节点 `vi` 的有向边。每个节点都有一个对应的 **得分** ，由数组 `score` 给出，其中 `score[i]` 表示节点 `i` 的得分。

你需要以 **有效的拓扑排序** 顺序处理这些节点。每个节点在处理顺序中被分配一个编号从 **1** 开始的位置。

将每个节点的得分乘以其在拓扑排序中的位置，然后求和，得到的值称为 **利润**。

请返回在所有合法拓扑排序中可获得的 **最大利润** 。

**拓扑排序** 是一个对 DAG 中所有节点的线性排序，使得每条有向边 `u → v` 中，节点 `u` 都出现在 `v` 之前。

---

- **示例 1：**

**输入：** n = 2, edges = [[0,1]], score = [2,3]

**输出：** 8

**解释：**

![图 0](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-29-22-58-37.png)

节点 1 依赖于节点 0，因此一个合法顺序是 `[0, 1]`。

| 节点 | 处理顺序 | 得分 | 乘数 | 利润计算  |
| ---- | -------- | ---- | ---- | --------- |
| 0    | 第 1 个  | 2    | 1    | 2 × 1 = 2 |
| 1    | 第 2 个  | 3    | 2    | 3 × 2 = 6 |

所有合法拓扑排序中可获得的最大总利润是 `2 + 6 = 8`。

---

- **示例 2：**

**输入：** n = 3, edges = [[0,1],[0,2]], score = [1,6,3]

**输出：** 25

**解释：**

![图 1](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-29-22-58-56.png)

节点 1 和 2 都依赖于节点 0，因此最优的合法顺序是 `[0, 2, 1]`。

| 节点 | 处理顺序 | 得分 | 乘数 | 利润计算   |
| ---- | -------- | ---- | ---- | ---------- |
| 0    | 第 1 个  | 1    | 1    | 1 × 1 = 1  |
| 2    | 第 2 个  | 3    | 2    | 3 × 2 = 6  |
| 1    | 第 3 个  | 6    | 3    | 6 × 3 = 18 |

所有合法拓扑排序中可获得的最大总利润是 `1 + 6 + 18 = 25`。

---

**提示：**

- `1 <= n == score.length <= 22`
- `1 <= score[i] <= 10^5`
- `0 <= edges.length <= n * (n - 1) / 2`
- `edges[i] == [ui, vi]` 表示一条从 `ui` 到 `vi` 的有向边。
- `0 <= ui, vi < n`
- `ui != vi`
- 输入图 **保证** 是一个 **DAG**。
- 不存在重复的边。

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
