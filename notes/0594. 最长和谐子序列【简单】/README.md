# [0594. 最长和谐子序列【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/0594.%20%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🫧 评价](#2--评价)
- [3. 🎯 s.1 - 哈希表统计法](#3--s1---哈希表统计法)
- [4. 🎯 s.2 - 排序后滑动窗口](#4--s2---排序后滑动窗口)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/longest-harmonious-subsequence/)

和谐数组是指一个数组里元素的最大值和最小值之间的差别 **正好是 `1`** 。

给你一个整数数组 `nums` ，请你在所有可能的 **子序列** 中找到最长的和谐子序列的长度。

> 子序列 是可以通过从另一个数组删除或不删除某些元素，但不更改其余元素的顺序得到的数组。

数组的 **子序列** 是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。

---

- **示例 1：**

```txt
输入：nums = [1,3,2,2,5,2,3,7]
输出：5
解释：
最长和谐子序列是 [3,2,2,2,3]。
```

- **示例 2：**

```txt
输入：nums = [1,2,3,4]
输出：2
解释：
最长和谐子序列是 [1,2]，[2,3] 和 [3,4]，长度都为 2。
```

- **示例 3：**

```txt
输入：nums = [1,1,1,1]
输出：0
解释：
不存在和谐子序列。
```

---

**提示：**

- `1 <= nums.length <= 2 * 10^4`
- `-10^9 <= nums[i] <= 10^9`

## 2. 🫧 评价

- `s.1 - 哈希表统计法` 时间更优
- `s.2 - 排序 + 双指针` 空间更优

## 3. 🎯 s.1 - 哈希表统计法

::: code-group

<<< ./solutions/1/1.js [js]

:::

- **时间复杂度**：$O(n)$
  - 遍历数组统计频次需要 $O(n)$ 时间
  - 遍历哈希表检查相邻元素需要 $O(k)$ 时间，其中 $k$ 是不同元素的个数，最坏情况下 $k = n$
  - 总体时间复杂度为 $O(n)$
- **空间复杂度**：$O(k)$
  - 需要哈希表存储每个元素的出现次数，最坏情况下需要 $O(n)$ 空间
- ![图 0](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-21-22-46-32.png)
- 解题思路
  - 解决这个问题的关键是理解和谐子序列的定义：**只包含两种数值，且它们相差为 1（如 x 和 x+1）**
  - **核心步骤**：
    1. 统计每个数字出现的频次
    2. 对于每个数字 x，检查 x+1 是否存在
    3. 如果存在，则 x 和 x+1 组成的子序列长度为 count(x) + count(x+1)
    4. 找到所有这样的组合中的最大长度

## 4. 🎯 s.2 - 排序后滑动窗口

::: code-group

<<< ./solutions/2/1.js [js]

:::

- **时间复杂度**：$O(n \log n)$
  - 排序操作需要 $O(n \log n)$ 时间
  - 双指针遍历需要 $O(n)$ 时间
  - 总体时间复杂度为 $O(n \log n)$
- **空间复杂度**：$O(1)$
  - 只使用了常数级别的额外空间（不考虑排序算法的额外空间）
- ![图 1](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-21-22-46-40.png)
