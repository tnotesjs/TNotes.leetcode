# [2614. 对角线上的质数【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/2614.%20%E5%AF%B9%E8%A7%92%E7%BA%BF%E4%B8%8A%E7%9A%84%E8%B4%A8%E6%95%B0%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 遍历 + 质数判定](#2--s1---遍历--质数判定)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/prime-in-diagonal/)

给你一个下标从 0 开始的二维整数数组 `nums`。

返回位于 `nums` 至少一条对角线上的最大质数。如果任一对角线上均不存在质数，返回 0。

注意：

- 如果某个整数大于 `1`，且不存在除 `1` 和自身之外的正整数因子，则认为该整数是一个质数。
- 如果存在整数 `i`，使得 `nums[i][i] = val` 或者 `nums[i][nums.length - i - 1]= val`，则认为整数 `val` 位于 `nums` 的一条对角线上。

![img](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-27-21-14-22.png)

在上图中，一条对角线是 `[1,5,9]`，而另一条对角线是 `[3,5,7]`。

---

示例 1：

```txt
输入：nums = [[1,2,3],[5,6,7],[9,10,11]]
输出：11

解释：
数字 1、3、6、9 和 11 是所有 "位于至少一条对角线上" 的数字。
由于 11 是最大的质数，故返回 11。
```

---

示例 2：

```txt
输入：nums = [[1,2,3],[5,17,7],[9,11,10]]
输出：17

解释：
数字 1、3、9、10 和 17 是所有满足"位于至少一条对角线上"的数字。
由于 17 是最大的质数，故返回 17。
```

---

提示：

- `1 <= nums.length <= 300`
- `nums.length == numsi.length`
- `1 <= nums[i][j] <= 4*10^6`

## 2. 🎯 s.1 - 遍历 + 质数判定

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(N \times \sqrt{M})$，其中 N 是矩阵边长，M 是矩阵中的最大值，需要遍历对角线并对每个数判断是否为质数
- 空间复杂度：$O(1)$，只使用常数额外空间

算法思路：

- 遍历矩阵的两条对角线：主对角线 `nums[i][i]` 和副对角线 `nums[i][n-i-1]`
- 对每个对角线上的数字判断是否为质数
- 质数判定：排除小于2的数、2是质数、偶数不是质数，然后检查从3到√n的所有奇数是否能整除
- 维护并返回遇到的最大质数，如果没有质数则返回0
