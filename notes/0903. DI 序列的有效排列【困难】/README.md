# [0903. DI 序列的有效排列【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/0903.%20DI%20%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%89%E6%95%88%E6%8E%92%E5%88%97%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/valid-permutations-for-di-sequence/)

给定一个长度为 `n` 的字符串 `s` ，其中 `s[i]` 是:

- `“D”` 意味着减少，或者
- `“I”` 意味着增加

**有效排列** 是对有 `n + 1` 个在 `[0, n]` 范围内的整数的一个排列 `perm` ，使得对所有的 `i`：

- 如果 `s[i] == 'D'`，那么 `perm[i] > perm[i+1]`，以及；
- 如果 `s[i] == 'I'`，那么 `perm[i] < perm[i+1]`。

返回 **_有效排列_** `perm`_的数量_ 。因为答案可能很大，所以请**返回你的答案对** `10^9 + 7` **取余**。

---

- **示例 1：**

```txt
输入：s = "DID"
输出：5
解释：
(0, 1, 2, 3) 的五个有效排列是：
(1, 0, 3, 2)
(2, 0, 3, 1)
(2, 1, 3, 0)
(3, 0, 2, 1)
(3, 1, 2, 0)
```

- **示例 2:**

```txt
输入: s = "D"
输出: 1
```

---

**提示:**

- `n == s.length`
- `1 <= n <= 200`
- `s[i]` 不是 `'I'` 就是 `'D'`

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
