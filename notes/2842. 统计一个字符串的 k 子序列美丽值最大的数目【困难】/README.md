# [2842. 统计一个字符串的 k 子序列美丽值最大的数目【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/2842.%20%E7%BB%9F%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20k%20%E5%AD%90%E5%BA%8F%E5%88%97%E7%BE%8E%E4%B8%BD%E5%80%BC%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B0%E7%9B%AE%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/count-k-subsequences-of-a-string-with-maximum-beauty/)

给你一个字符串 `s` 和一个整数 `k`。

k 子序列指的是 `s` 的一个长度为 `k` 的 子序列 ，且所有字符都是 唯一 的，也就是说每个字符在子序列里只出现过一次。

定义 `f(c)` 为字符 `c` 在 `s` 中出现的次数。

k 子序列的 美丽值 定义为这个子序列中每一个字符 `c` 的 `f(c)` 之 和。

比方说，`s = "abbbdd"` 和 `k = 2` ，我们有：

- `f('a') = 1`, `f('b') = 3`, `f('d') = 2`
- `s` 的部分 k 子序列为：
  - `"*ab*bbdd"` -> `"ab"` ，美丽值为 `f('a') + f('b') = 4`
  - `"*a*bbb*d*d"` -> `"ad"` ，美丽值为 `f('a') + f('d') = 3`
  - `"a*b*bb*d*d"` -> `"bd"` ，美丽值为 `f('b') + f('d') = 5`

请你返回一个整数，表示所有 k 子序列 里面 美丽值 是 最大值 的子序列数目。由于答案可能很大，将结果对 `10^9 + 7` 取余后返回。

一个字符串的子序列指的是从原字符串里面删除一些字符（也可能一个字符也不删除），不改变剩下字符顺序连接得到的新字符串。

注意：

- `f(c)` 指的是字符 `c` 在字符串 `s` 的出现次数，不是在 k 子序列里的出现次数。
- 两个 k 子序列如果有任何一个字符在原字符串中的下标不同，则它们是两个不同的子序列。所以两个不同的 k 子序列可能产生相同的字符串。

---

- 示例 1：

```txt
输入：s = "bcca", k = 2
输出：4
解释：s 中我们有 f('a') = 1 ，f('b') = 1 和 f('c') = 2。
s 的 k 子序列为：
bcca ，美丽值为 f('b') + f('c') = 3
bcca ，美丽值为 f('b') + f('c') = 3
bcca ，美丽值为 f('b') + f('a') = 2
bcca ，美丽值为 f('c') + f('a') = 3
bcca ，美丽值为 f('c') + f('a') = 3
总共有 4 个 k 子序列美丽值为最大值 3。
所以答案为 4。
```

- 示例 2：

```txt
输入：s = "abbcd", k = 4
输出：2
解释：s 中我们有 f('a') = 1 ，f('b') = 2 ，f('c') = 1 和 f('d') = 1。
s 的 k 子序列为：
abbcd ，美丽值为 f('a') + f('b') + f('c') + f('d') = 5
abbcd ，美丽值为 f('a') + f('b') + f('c') + f('d') = 5
总共有 2 个 k 子序列美丽值为最大值 5。
所以答案为 2。
```

---

提示：

- `1 <= s.length <= 2 * 10^5`
- `1 <= k <= s.length`
- `s` 只包含小写英文字母。

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
