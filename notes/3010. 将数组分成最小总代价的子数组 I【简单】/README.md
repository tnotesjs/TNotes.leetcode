# [3010. 将数组分成最小总代价的子数组 I【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3010.%20%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E6%9C%80%E5%B0%8F%E6%80%BB%E4%BB%A3%E4%BB%B7%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%20I%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 贪心](#2--s1---贪心)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/divide-an-array-into-subarrays-with-minimum-cost-i/)

给你一个长度为 `n` 的整数数组 `nums`。

一个数组的 代价 是它的 第一个 元素。比方说，`[1,2,3]` 的代价是 `1` ，`[3,4,1]` 的代价是 `3`。

你需要将 `nums` 分成 `3` 个 连续且没有交集 的子数组。

请你返回这些子数组的 最小 代价 总和。

> 子数组 是数组中元素的连续序列。

---

示例 1：

```txt
输入：nums = [1,2,3,12]
输出：6
解释：最佳分割成 3 个子数组的方案是：[1] ，[2] 和 [3,12] ，总代价为 1 + 2 + 3 = 6。
其他得到 3 个子数组的方案是：
- [1] ，[2,3] 和 [12] ，总代价是 1 + 2 + 12 = 15。
- [1,2] ，[3] 和 [12] ，总代价是 1 + 3 + 12 = 16。
```

---

示例 2：

```txt
输入：nums = [5,4,3]
输出：12
解释：最佳分割成 3 个子数组的方案是：[5] ，[4] 和 [3] ，总代价为 5 + 4 + 3 = 12。
12 是所有分割方案里的最小总代价。
```

---

示例 3：

```txt
输入：nums = [10,3,1,1]
输出：12
解释：最佳分割成 3 个子数组的方案是：[10,3] ，[1] 和 [1] ，总代价为 10 + 1 + 1 = 12。
12 是所有分割方案里的最小总代价。
```

---

提示：

- `3 <= n <= 50`
- `1 <= nums[i] <= 50`

## 2. 🎯 s.1 - 贪心

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(n)$，其中 n 是数组长度
- 空间复杂度：$O(1)$，只使用了常数级别的额外空间

算法思路：

- 分成 3 个子数组，第一个子数组必须包含 `nums[0]`，其代价固定为 `nums[0]`
- 第二和第三个子数组的起始元素可以是 `nums[1:]` 中的任意两个不同位置的元素
- 为了使总代价最小，需要在 `nums[1:]` 中找到最小的两个元素
- 遍历一次数组，维护最小值和次小值，最终答案为 `nums[0] + min1 + min2`
