# [3404. 统计特殊子序列的数目【中等】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3404.%20%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/count-special-subsequences/)

给你一个只包含正整数的数组 `nums` 。

**特殊子序列** 是一个长度为 4 的子序列，用下标 `(p, q, r, s)` 表示，它们满足 `p < q < r < s` ，且这个子序列 **必须** 满足以下条件：

- `nums[p] * nums[r] == nums[q] * nums[s]`
- 相邻坐标之间至少间隔 **一个** 数字。换句话说，`q - p > 1` ，`r - q > 1` 且 `s - r > 1` 。

子序列指的是从原数组中删除零个或者更多元素后，剩下元素不改变顺序组成的数字序列。

请你返回 `nums` 中不同 **特殊子序列** 的数目。

---

- **示例 1：**

**输入：** nums = [1,2,3,4,3,6,1]

**输出：** 1

**解释：**

`nums` 中只有一个特殊子序列。

- `(p, q, r, s) = (0, 2, 4, 6)` ：
  - 对应的元素为 `(1, 3, 3, 1)` 。
  - `nums[p] * nums[r] = nums[0] * nums[4] = 1 * 3 = 3`
  - `nums[q] * nums[s] = nums[2] * nums[6] = 3 * 1 = 3`

---

- **示例 2：**

**输入：** nums = [3,4,3,4,3,4,3,4]

**输出：** 3

**解释：**

`nums` 中共有三个特殊子序列。

- `(p, q, r, s) = (0, 2, 4, 6)` ：
  - 对应元素为 `(3, 3, 3, 3)` 。
  - `nums[p] * nums[r] = nums[0] * nums[4] = 3 * 3 = 9`
  - `nums[q] * nums[s] = nums[2] * nums[6] = 3 * 3 = 9`
- `(p, q, r, s) = (1, 3, 5, 7)` ：
  - 对应元素为 `(4, 4, 4, 4)` 。
  - `nums[p] * nums[r] = nums[1] * nums[5] = 4 * 4 = 16`
  - `nums[q] * nums[s] = nums[3] * nums[7] = 4 * 4 = 16`
- `(p, q, r, s) = (0, 2, 5, 7)` ：
  - 对应元素为 `(3, 3, 4, 4)` 。
  - `nums[p] * nums[r] = nums[0] * nums[5] = 3 * 4 = 12`
  - `nums[q] * nums[s] = nums[2] * nums[7] = 3 * 4 = 12`

---

**提示：**

- `7 <= nums.length <= 1000`
- `1 <= nums[i] <= 1000`

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
