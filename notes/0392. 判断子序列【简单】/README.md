# [0392. 判断子序列【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/0392.%20%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 暴力解法](#2--s1---暴力解法)
- [3. 🔗 引用](#3--引用)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/is-subsequence/)

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

**进阶：**

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10 亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

**致谢：**

特别感谢 [@pbrother][1]  添加此问题并且创建所有测试用例。

---

- **示例 1：**

```txt
输入：s = "abc", t = "ahbgdc"
输出：true
```

- **示例 2：**

```txt
输入：s = "axc", t = "ahbgdc"
输出：false
```

---

**提示：**

- `0 <= s.length <= 100`
- `0 <= t.length <= 10^4`
- 两个字符串都只由小写字符组成。

## 2. 🎯 s.1 - 暴力解法

::: code-group

<<< ./solutions/1/1.js [js]

:::

- **时间复杂度**：$O(n)$，其中 n 是 `t` 的长度，最多遍历一次 `t`
- **空间复杂度**：$O(1)$，只用了常数空间
- 解题思路：
  - 使用 **双指针**
    - 一个指针 `i` 遍历 `s`
    - 一个指针 `j` 遍历 `t`
  - 遍历 `t`，如果 `t[j] === s[i]`，说明匹配了一个字符，`i++`。
  - 最后如果 `i` 走完了整个 `s`，说明 `s` 是 `t` 的子序列。

## 3. 🔗 引用

- [@pbrother][1]

[1]: https://leetcode.com/pbrother/
