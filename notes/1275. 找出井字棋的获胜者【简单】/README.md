# [1275. 找出井字棋的获胜者【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/1275.%20%E6%89%BE%E5%87%BA%E4%BA%95%E5%AD%97%E6%A3%8B%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 行列对角计数](#2--s1---行列对角计数)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/find-winner-on-a-tic-tac-toe-game/)

井字棋 是由两个玩家 `A` 和 `B` 在 `3 x 3` 的棋盘上进行的游戏。井字棋游戏的规则如下：

- 玩家轮流将棋子放在空方格 (`' '`) 上。
- 第一个玩家 `A` 总是用 `'X'` 作为棋子，而第二个玩家 `B` 总是用 `'O'` 作为棋子。
- `'X'` 和 `'O'` 只能放在空方格中，而不能放在已经被占用的方格上。
- 只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。
- 如果所有方块都放满棋子（不为空），游戏也会结束。
- 游戏结束后，棋子无法再进行任何移动。

给你一个数组 `moves`，其中 `moves[i] = [rowi, coli]` 表示第 `i` 次移动在 `grid[rowi][coli]`。如果游戏存在获胜者（`A` 或 `B`），就返回该游戏的获胜者；如果游戏以平局结束，则返回 `"Draw"`；如果仍会有行动（游戏未结束），则返回 `"Pending"`。

你可以假设 `moves` 都有效（遵循井字棋规则），网格最初是空的，`A` 将先行动。

---

示例 1：

![img](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-17-20-06-58.png)

```txt
输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]
输出："A"
```

解释："A" 获胜，他总是先走。

---

示例 2：

![img](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-17-20-07-06.png)

```txt
输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
输出："B"
```

解释："B" 获胜。

---

示例 3：

![img](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-17-20-07-19.png)

```txt
输入：moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]
输出："Draw"
```

解释：由于没有办法再行动，游戏以平局结束。

---

提示：

- `1 <= moves.length <= 9`
- `moves[i].length == 2`
- `0 <= moves[i][j] <= 2`
- `moves` 里没有重复的元素。
- `moves` 遵循井字棋的规则。

## 2. 🎯 s.1 - 行列对角计数

::: code-group

<<< ./solutions/1/1.js [js]

<<< ./solutions/1/1.c [c]

<<< ./solutions/1/1.py [py]

:::

- 时间复杂度：$O(L)$，$L$ 为本局落子步数（至多 9）
- 空间复杂度：$O(1)$，仅用常数个行列与对角计数器

算法思路：

- 用 `+1/-1` 表示当前落子玩家，在 3 行、3 列、主对角线、副对角线四类计数器上累计
- 每次落子同步更新对应计数，若某个计数的绝对值变为 3，则当前玩家立即获胜
- 遍历完所有落子仍无胜者时，步数为 9 返回 `"Draw"`，否则返回 `"Pending"`
