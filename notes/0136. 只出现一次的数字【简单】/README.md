# [0136. 只出现一次的数字【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/0136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 异或运算](#2--s1---异或运算)
- [3. 🎯 s.2 - 使用 Map 计数](#3--s2---使用-map-计数)
- [4. 🎯 s.3 - 使用 Set](#4--s3---使用-set)
- [5. 🎯 s.4 - 数学求和](#5--s4---数学求和)
- [6. 🎯 s.5 - 排序 ➕ 双指针查找](#6--s5---排序--双指针查找)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/single-number/)

给你一个 非空 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

---

示例 1 ：

- 输入：nums = [2,2,1]
- 输出：1

---

示例 2 ：

- 输入：nums = [4,1,2,1,2]
- 输出：4

---

示例 3 ：

- 输入：nums = [1]
- 输出：1

---

提示：

- `1 <= nums.length <= 3 * 10^4`
- `-3 * 10^4 <= nums[i] <= 3 * 10^4`
- 除了某个元素只出现一次以外，其余每个元素均出现两次。

## 2. 🎯 s.1 - 异或运算

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(n)$ - 需要遍历数组一次，对每个元素执行常数时间的异或操作
- 空间复杂度：$O(1)$ - 只使用了一个额外变量 result，空间占用为常数级别

## 3. 🎯 s.2 - 使用 Map 计数

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(n)$ - 需要遍历数组两次，第一次统计频次，第二次查找出现次数为 1 的元素，均为线性时间
- 空间复杂度：$O(n)$ - 使用了 Map 数据结构存储每个元素及其出现次数，最坏情况下需要存储 n 个不同的元素

## 4. 🎯 s.3 - 使用 Set

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(n)$ - 需要遍历数组一次，每次对 Set 的操作（添加、删除、检查）都是常数时间
- 空间复杂度：$O(n)$ - 使用了 Set 数据结构，在最坏情况下需要存储一半的元素（当遍历到一半时）

## 5. 🎯 s.4 - 数学求和

::: code-group

<<< ./solutions/4/1.js [js]

:::

- 时间复杂度：$O(n)$ - 需要遍历数组一次构建 Set，遍历 Set 一次计算唯一元素和，再遍历数组一次计算总和，均为线性时间
- 空间复杂度：$O(n)$ - 使用了 Set 数据结构存储所有不重复的元素

## 6. 🎯 s.5 - 排序 ➕ 双指针查找

::: code-group

<<< ./solutions/5/1.js [js]

:::

- 时间复杂度：$O(n \log n)$ - 主要时间消耗在排序操作上，排序时间复杂度为 $O(n \log n)$，后续的遍历为 $O(n)$
- 空间复杂度：$O(1)$ - 排序是原地进行的，只使用了常数级别的额外空间
