# [2818. 操作使得分最大【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/2818.%20%E6%93%8D%E4%BD%9C%E4%BD%BF%E5%BE%97%E5%88%86%E6%9C%80%E5%A4%A7%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/apply-operations-to-maximize-score/)

给你一个长度为 `n` 的正整数数组 `nums` 和一个整数 `k` 。

一开始，你的分数为 `1` 。你可以进行以下操作至多 `k` 次，目标是使你的分数最大：

- 选择一个之前没有选过的 **非空** 子数组 `nums[l, ..., r]` 。
- 从 `nums[l, ..., r]` 里面选择一个 **质数分数** 最高的元素 `x` 。如果多个元素质数分数相同且最高，选择下标最小的一个。
- 将你的分数乘以 `x` 。

`nums[l, ..., r]` 表示 `nums` 中起始下标为 `l` ，结束下标为 `r` 的子数组，两个端点都包含。

一个整数的 **质数分数** 等于 `x` 不同质因子的数目。比方说， `300` 的质数分数为 `3` ，因为 `300 = 2 * 2 * 3 * 5 * 5` 。

请你返回进行至多 `k` 次操作后，可以得到的 **最大分数** 。

由于答案可能很大，请你将结果对 `10^9 + 7` 取余后返回。

---

- **示例 1：**

```txt
输入：nums = [8,3,9,3,8], k = 2
输出：81
解释：进行以下操作可以得到分数 81 ：
- 选择子数组 nums[2, ..., 2] 。
  nums[2] 是子数组中唯一的元素。
  所以我们将分数乘以 nums[2] ，分数变为 1 * 9 = 9 。
- 选择子数组 nums[2, ..., 3] 。
  nums[2] 和 nums[3] 质数分数都为 1 ，但是 nums[2] 下标更小。
  所以我们将分数乘以 nums[2] ，分数变为 9 * 9 = 81 。
  81 是可以得到的最高得分。
```

- **示例 2：**

```txt
输入：nums = [19,12,14,6,10,18], k = 3
输出：4788
解释：进行以下操作可以得到分数 4788 ：
- 选择子数组 nums[0, ..., 0] 。
  nums[0] 是子数组中唯一的元素。
  所以我们将分数乘以 nums[0] ，分数变为 1 * 19 = 19 。
- 选择子数组 nums[5, ..., 5] 。
  nums[5] 是子数组中唯一的元素。
  所以我们将分数乘以 nums[5] ，分数变为 19 * 18 = 342 。
- 选择子数组 nums[2, ..., 3] 。
  nums[2] 和 nums[3] 质数分数都为 2，但是 nums[2] 下标更小。
  所以我们将分数乘以 nums[2] ，分数变为  342 * 14 = 4788 。
  4788 是可以得到的最高的分。
```

---

**提示：**

- `1 <= nums.length == n <= 10^5`
- `1 <= nums[i] <= 10^5`
- `1 <= k <= min(n * (n + 1) / 2, 10^9)`

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
