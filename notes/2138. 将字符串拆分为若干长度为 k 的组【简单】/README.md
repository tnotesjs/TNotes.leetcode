# [2138. 将字符串拆分为若干长度为 k 的组【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/2138.%20%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86%E4%B8%BA%E8%8B%A5%E5%B9%B2%E9%95%BF%E5%BA%A6%E4%B8%BA%20k%20%E7%9A%84%E7%BB%84%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/divide-a-string-into-groups-of-size-k/)

字符串 `s` 可以按下述步骤划分为若干长度为 `k` 的组：

- 第一组由字符串中的前 `k` 个字符组成，第二组由接下来的 `k` 个字符串组成，依此类推。每个字符都能够成为 **某一个** 组的一部分。
- 对于最后一组，如果字符串剩下的字符 **不足** `k` 个，需使用字符 `fill` 来补全这一组字符。

注意，在去除最后一个组的填充字符 `fill`（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是 `s` 。

给你一个字符串 `s` ，以及每组的长度 `k` 和一个用于填充的字符 `fill` ，按上述步骤处理之后，返回一个字符串数组，该数组表示 `s` 分组后 **每个组的组成情况** 。

---

- **示例 1：**

```txt
输入：s = "abcdefghi", k = 3, fill = 'x'
输出：["abc","def","ghi"]
解释：
前 3 个字符是 "abc" ，形成第一组。
接下来 3 个字符是 "def" ，形成第二组。
最后 3 个字符是 "ghi" ，形成第三组。
由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。
因此，形成 3 组，分别是 "abc"、"def" 和 "ghi" 。
```

- **示例 2：**

```txt
输入：s = "abcdefghij", k = 3, fill = 'x'
输出：["abc","def","ghi","jxx"]
解释：
与前一个例子类似，形成前三组 "abc"、"def" 和 "ghi" 。
对于最后一组，字符串中仅剩下字符 'j' 可以用。为了补全这一组，使用填充字符 'x' 两次。
因此，形成 4 组，分别是 "abc"、"def"、"ghi" 和 "jxx" 。
```

---

**提示：**

- `1 <= s.length <= 100`
- `s` 仅由小写英文字母组成
- `1 <= k <= 100`
- `fill` 是一个小写英文字母

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
