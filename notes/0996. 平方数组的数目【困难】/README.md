# [0996. 平方数组的数目【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/0996.%20%E5%B9%B3%E6%96%B9%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 回溯 + 剪枝](#2--s1---回溯--剪枝)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/number-of-squareful-arrays/)

如果一个数组的任意两个相邻元素之和都是完全平方数，则该数组称为平方数组。

给定一个整数数组 `nums`，返回所有属于平方数组的 `nums` 的排列数量。

如果存在某个索引 `i` 使得 `perm1[i] != perm2[i]`，则认为两个排列 `perm1` 和 `perm2` 不同。

---

示例 1：

```txt
输入：nums = [1,17,8]
输出：2

解释：
[1,8,17] 和 [17,8,1] 是有效的排列。
```

---

示例 2：

```txt
输入：nums = [2,2,2]
输出：1
```

---

提示：

- `1 <= nums.length <= 12`
- `0 <= nums[i] <= 10^9`

## 2. 🎯 s.1 - 回溯 + 剪枝

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(n! \times n)$，其中 n 是数组长度，最坏情况需要遍历所有排列
- 空间复杂度：$O(n^2)$，图的邻接表和递归栈空间

算法思路：

- 预处理：排序数组便于去重，构建图记录哪些索引对应的数字可以相邻（和为完全平方数）
- 回溯框架：从空路径开始，逐个选择未使用的数字添加到路径中
- 剪枝策略 1：跳过已使用的元素和重复元素（`nums[i] === nums[i-1]` 且前一个未使用）
- 剪枝策略 2：检查当前元素是否可以与路径最后一个元素相邻，不满足则跳过
- 终止条件：当路径长度等于 n 时，找到一个有效排列，计数加 1
