# [2202. K 次操作后最大化顶端元素【中等】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/2202.%20K%20%E6%AC%A1%E6%93%8D%E4%BD%9C%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E9%A1%B6%E7%AB%AF%E5%85%83%E7%B4%A0%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/maximize-the-topmost-element-after-k-moves/)

给你一个下标从 0 开始的整数数组 `nums` ，它表示一个 堆 ，其中 `nums[0]` 是堆顶的元素。

每一次操作中，你可以执行以下操作 之一 ：

- 如果堆非空，那么 删除 堆顶端的元素。
- 如果存在 1 个或者多个被删除的元素，你可以从它们中选择任何一个，添加 回堆顶，这个元素成为新的堆顶元素。

同时给你一个整数 `k` ，它表示你总共需要执行操作的次数。

请你返回 恰好 执行 `k` 次操作以后，堆顶元素的 最大值 。如果执行完 `k` 次操作以后，堆一定为空，请你返回 `-1` 。

---

- 示例 1：

```txt
输入：nums = [5,2,2,4,0,6], k = 4
输出：5
解释：
4 次操作后，堆顶元素为 5 的方法之一为：
- 第 1 次操作：删除堆顶元素 5 ，堆变为 [2,2,4,0,6] 。
- 第 2 次操作：删除堆顶元素 2 ，堆变为 [2,4,0,6] 。
- 第 3 次操作：删除堆顶元素 2 ，堆变为 [4,0,6] 。
- 第 4 次操作：将 5 添加回堆顶，堆变为 [5,4,0,6] 。
注意，这不是最后堆顶元素为 5 的唯一方式。但可以证明，4 次操作以后 5 是能得到的最大堆顶元素。
```

- 示例 2：

```txt
输入：nums = [2], k = 1
输出：-1
解释：
第 1 次操作中，我们唯一的选择是将堆顶元素弹出堆。
由于 1 次操作后无法得到一个非空的堆，所以我们返回 -1 。
```

---

提示：

- `1 <= nums.length <= 10^5`
- `0 <= nums[i], k <= 10^9`

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
