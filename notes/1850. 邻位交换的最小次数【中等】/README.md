# [1850. 邻位交换的最小次数【中等】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/1850.%20%E9%82%BB%E4%BD%8D%E4%BA%A4%E6%8D%A2%E7%9A%84%E6%9C%80%E5%B0%8F%E6%AC%A1%E6%95%B0%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/)

给你一个表示大整数的字符串 `num` ，和一个整数 `k` 。

如果某个整数是 `num` 中各位数字的一个 **排列** 且它的 **值大于** `num` ，则称这个整数为 **妙数** 。可能存在很多妙数，但是只需要关注 **值最小** 的那些。

- 例如，`num = "5489355142"` ：
  - 第 1 个最小妙数是 `"5489355214"`
  - 第 2 个最小妙数是 `"5489355241"`
  - 第 3 个最小妙数是 `"5489355412"`
  - 第 4 个最小妙数是 `"5489355421"`

返回要得到第 `k` 个 **最小妙数** 需要对 `num` 执行的 **相邻位数字交换的最小次数** 。

测试用例是按存在第 `k` 个最小妙数而生成的。

---

- **示例 1：**

```txt
输入：num = "5489355142", k = 4
输出：2
解释：第 4 个最小妙数是 "5489355421" ，要想得到这个数字：
- 交换下标 7 和下标 8 对应的位："5489355142" -> "5489355412"
- 交换下标 8 和下标 9 对应的位："5489355412" -> "5489355421"
```

- **示例 2：**

```txt
输入：num = "11112", k = 4
输出：4
解释：第 4 个最小妙数是 "21111" ，要想得到这个数字：
- 交换下标 3 和下标 4 对应的位："11112" -> "11121"
- 交换下标 2 和下标 3 对应的位："11121" -> "11211"
- 交换下标 1 和下标 2 对应的位："11211" -> "12111"
- 交换下标 0 和下标 1 对应的位："12111" -> "21111"
```

- **示例 3：**

```txt
输入：num = "00123", k = 1
输出：1
解释：第 1 个最小妙数是 "00132" ，要想得到这个数字：
- 交换下标 3 和下标 4 对应的位："00123" -> "00132"
```

---

**提示：**

- `2 <= num.length <= 1000`
- `1 <= k <= 1000`
- `num` 仅由数字组成

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
