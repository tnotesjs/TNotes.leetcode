# [0401. 二进制手表【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/0401.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 暴力解法](#2--s1---暴力解法)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/binary-watch)

二进制手表顶部有 4 个 LED 代表 **小时（0-11）**，底部的 6 个 LED 代表 **分钟（0-59）**。每个 LED 代表一个 0 或 1，最低位在右侧。

- 例如，下面的二进制手表读取 `"4:51"` 。

![图 0](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-12-13-29-27.png)

给你一个整数 `turnedOn` ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 **按任意顺序** 返回答案。

小时不会以零开头：

- 例如，`"01:00"` 是无效的时间，正确的写法应该是 `"1:00"` 。

分钟必须由两位数组成，可能会以零开头：

- 例如，`"10:2"` 是无效的时间，正确的写法应该是 `"10:02"` 。

---

- **示例 1：**

```txt
输入：turnedOn = 1
输出：["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"]
```

- **示例 2：**

```txt
输入：turnedOn = 9
输出：[]
```

---

**提示：**

- `0 <= turnedOn <= 10`

## 2. 🎯 s.1 - 暴力解法

::: code-group

<<< ./solutions/1/1.js [js-1]

<<< ./solutions/1/2.js [js-2]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
- `js-1` 直接将 n 转为字符串二进制的形式，通过切片来暴力计算 1 的数量
- `js-2` 通过位运算来计算 n 对应的二进制中 1 的数量
- 解题思路：
  - 我们可以 **枚举所有合法的小时和分钟组合**，并检查它们的二进制中 1 的个数之和是否等于 `turnedOn`。
  - 小时范围：0 ~ 11 → 枚举 `h = 0 to 11`
  - 分钟范围：0 ~ 59 → 枚举 `m = 0 to 59`
  - 对于每个 `(h, m)`，计算 `bitCount(h) + bitCount(m) === turnedOn`
  - 如果符合，格式化后加入结果数组
