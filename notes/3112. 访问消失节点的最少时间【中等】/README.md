# [3112. 访问消失节点的最少时间【中等】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3112.%20%E8%AE%BF%E9%97%AE%E6%B6%88%E5%A4%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/minimum-time-to-visit-disappearing-nodes/)

给你一个二维数组 `edges` 表示一个 `n` 个点的无向图，其中 `edges[i] = [ui, vi, lengthi]` 表示节点 `ui` 和节点 `vi` 之间有一条需要 `lengthi` 单位时间通过的无向边。

同时给你一个数组 `disappear` ，其中 `disappear[i]` 表示节点 `i` 从图中消失的时间点，在那一刻及以后，你无法再访问这个节点。

注意，图有可能一开始是不连通的，两个节点之间也可能有多条边。

请你返回数组 `answer` ，`answer[i]` 表示从节点 `0` 到节点 `i` 需要的 最少 单位时间。如果从节点 `0` 出发 无法 到达节点 `i` ，那么 `answer[i]` 为 `-1`。

---

示例 1：

![img](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-29-07-23-48.png)

- 输入： n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]
- 输出： [0,-1,4]
- 解释：
  - 我们从节点 0 出发，目的是用最少的时间在其他节点消失之前到达它们。
  - 对于节点 0 ，我们不需要任何时间，因为它就是我们的起点。
  - 对于节点 1 ，我们需要至少 2 单位时间，通过 `edges[0]` 到达。但当我们到达的时候，它已经消失了，所以我们无法到达它。
  - 对于节点 2 ，我们需要至少 4 单位时间，通过 `edges[2]` 到达。

---

示例 2：

![img](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-29-07-23-42.png)

- 输入： n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]
- 输出： [0,2,3]
- 解释：
  - 我们从节点 0 出发，目的是用最少的时间在其他节点消失之前到达它们。
  - 对于节点 0 ，我们不需要任何时间，因为它就是我们的起点。
  - 对于节点 1 ，我们需要至少 2 单位时间，通过 `edges[0]` 到达。
  - 对于节点 2 ，我们需要至少 3 单位时间，通过 `edges[0]` 和 `edges[1]` 到达。

---

示例 3：

- 输入： n = 2, edges = [[0,1,1]], disappear = [1,1]
- 输出： [0,-1]
- 解释：
  - 当我们到达节点 1 的时候，它恰好消失，所以我们无法到达节点 1。

---

提示：

- `1 <= n <= 5 * 10^4`
- `0 <= edges.length <= 10^5`
- `edges[i] == [ui, vi, lengthi]`
- `0 <= ui, vi <= n - 1`
- `1 <= lengthi <= 10^5`
- `disappear.length == n`
- `1 <= disappear[i] <= 10^5`

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
