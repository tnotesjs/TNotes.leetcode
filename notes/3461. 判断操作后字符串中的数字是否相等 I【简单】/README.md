# [3461. 判断操作后字符串中的数字是否相等 I【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3461.%20%E5%88%A4%E6%96%AD%E6%93%8D%E4%BD%9C%E5%90%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%20I%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 模拟](#2--s1---模拟)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/check-if-digits-are-equal-in-string-after-operations-i/)

给你一个由数字组成的字符串 `s`。重复执行以下操作，直到字符串恰好包含 两个 数字：

- 从第一个数字开始，对于 `s` 中的每一对连续数字，计算这两个数字的和 模 10。
- 用计算得到的新数字依次替换 `s` 的每一个字符，并保持原本的顺序。

如果 `s` 最后剩下的两个数字 相同 ，返回 `true`。否则，返回 `false`。

---

示例 1：

输入： s = "3902"

输出： true

解释：

- 一开始，`s = "3902"`
- 第一次操作：
  - `(s[0] + s[1]) % 10 = (3 + 9) % 10 = 2`
  - `(s[1] + s[2]) % 10 = (9 + 0) % 10 = 9`
  - `(s[2] + s[3]) % 10 = (0 + 2) % 10 = 2`
  - `s` 变为 `"292"`
- 第二次操作：
  - `(s[0] + s[1]) % 10 = (2 + 9) % 10 = 1`
  - `(s[1] + s[2]) % 10 = (9 + 2) % 10 = 1`
  - `s` 变为 `"11"`
- 由于 `"11"` 中的数字相同，输出为 `true`。

---

示例 2：

输入： s = "34789"

输出： false

解释：

- 一开始，`s = "34789"`。
- 第一次操作后，`s = "7157"`。
- 第二次操作后，`s = "862"`。
- 第三次操作后，`s = "48"`。
- 由于 `'4' != '8'`，输出为 `false`。

---

提示：

- `3 <= s.length <= 100`
- `s` 仅由数字组成。

## 2. 🎯 s.1 - 模拟

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(n^2)$，其中 n 是字符串长度，需要执行 n-2 次操作，每次操作遍历当前数组
- 空间复杂度：$O(n)$，需要存储中间结果数组

解题思路：

- 按题意直接模拟：每次将相邻两个数字之和对 10 取模，生成新数组
- 重复操作直到数组长度为 2
- 比较最后剩余的两个数字是否相等
