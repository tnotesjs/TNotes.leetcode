# [2509. 查询树中环的长度【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/2509.%20%E6%9F%A5%E8%AF%A2%E6%A0%91%E4%B8%AD%E7%8E%AF%E7%9A%84%E9%95%BF%E5%BA%A6%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/cycle-length-queries-in-a-tree/)

给你一个整数  `n` ，表示你有一棵含有  `2^n - 1`  个节点的 **完全二叉树** 。根节点的编号是  `1` ，树中编号在`[1, 2^n - 1 - 1]`  之间，编号为  `val`  的节点都有两个子节点，满足：

- 左子节点的编号为  `2 * val`
- 右子节点的编号为  `2 * val + 1`

给你一个长度为 `m`  的查询数组 `queries` ，它是一个二维整数数组，其中  `queries[i] = [ai, bi]` 。对于每个查询，求出以下问题的解：

1. 在节点编号为  `ai` 和  `bi`  之间添加一条边。
2. 求出图中环的长度。
3. 删除节点编号为  `ai` 和  `bi`  之间新添加的边。

**注意：**

- **环** 是开始和结束于同一节点的一条路径，路径中每条边都只会被访问一次。
- 环的长度是环中边的数目。
- 在树中添加额外的边后，两个点之间可能会有多条边。

请你返回一个长度为 `m`  的数组  `answer` ，其中  `answer[i]`  是第  `i`  个查询的结果*。*

---

- **示例 1：**

![图 0](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-27-20-37-54.png)

```txt
输入：n = 3, queries = [[5,3],[4,7],[2,3]]
输出：[4,5,3]
解释：上图是一棵有 23 - 1 个节点的树。红色节点表示添加额外边后形成环的节点。
- 在节点 3 和节点 5 之间添加边后，环为 [5,2,1,3] ，所以第一个查询的结果是 4 。删掉添加的边后处理下一个查询。
- 在节点 4 和节点 7 之间添加边后，环为 [4,2,1,3,7] ，所以第二个查询的结果是 5 。删掉添加的边后处理下一个查询。
- 在节点 2 和节点 3 之间添加边后，环为 [2,1,3] ，所以第三个查询的结果是 3 。删掉添加的边。
```

---

- **示例 2：**

![图 1](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-27-20-38-03.png)

```txt
输入：n = 2, queries = [[1,2]]
输出：[2]
解释：上图是一棵有 22 - 1 个节点的树。红色节点表示添加额外边后形成环的节点。
- 在节点 1 和节点 2 之间添加边后，环为 [2,1] ，所以第一个查询的结果是 2 。删掉添加的边。
```

---

**提示：**

- `2 <= n <= 30`
- `m == queries.length`
- `1 <= m <= 10^5`
- `queries[i].length == 2`
- `1 <= ai, bi <= 2^n - 1`
- `ai != bi`

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
