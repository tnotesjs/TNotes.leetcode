# [0980. 不同路径 III【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/0980.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20III%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 回溯](#2--s1---回溯)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/unique-paths-iii/)

在二维网格 `grid` 上，有 4 种类型的方格：

- `1` 表示起始方格。且只有一个起始方格。
- `2` 表示结束方格，且只有一个结束方格。
- `0` 表示我们可以走过的空方格。
- `-1` 表示我们无法跨越的障碍。

返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。

每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。

---

示例 1：

```txt
输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
输出：2

解释：
我们有以下两条路径：
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
```

---

示例 2：

```txt
输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]
输出：4

解释：
我们有以下四条路径：
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
```

---

示例 3：

```txt
输入：[[0,1],[2,0]]
输出：0

解释：
没有一条路能完全穿过每一个空的方格一次。
请注意，起始和结束方格可以位于网格中的任意位置。
```

---

提示：

- `1 <= grid.length * grid[0].length <= 20`

## 2. 🎯 s.1 - 回溯

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(4^{m \times n})$，其中 m 和 n 是网格的行数和列数，最坏情况下需要探索所有可能的路径
- 空间复杂度：$O(m \times n)$，递归栈的深度最多为网格中所有方格的数量

算法思路：

- 预处理：统计空方格数量（值为 0 的格子）并找到起点位置（值为 1 的格子）
- 回溯框架：从起点开始深度优先搜索，尝试四个方向移动，标记已访问的格子为 -1
- 终止条件：到达终点（值为 2 的格子）时，检查剩余空方格数量是否为 0，是则找到一条有效路径
- 剩余计数：维护 `remaining` 变量记录还需经过的空方格数量，每经过一个空方格减 1
- 状态恢复：回溯时恢复当前格子的原始值，允许其他路径访问
- 路径统计：每找到一条满足条件的路径，计数器加 1
