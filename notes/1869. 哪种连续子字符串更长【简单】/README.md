# [1869. 哪种连续子字符串更长【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/1869.%20%E5%93%AA%E7%A7%8D%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%B4%E9%95%BF%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 暴力解法](#2--s1---暴力解法)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/longer-contiguous-segments-of-ones-than-zeros/)

给你一个二进制字符串 `s`。如果字符串中由 `1` 组成的最长连续子字符串严格长于由 `0` 组成的最长连续子字符串，返回 `true`；否则，返回 `false`。

- 例如，`s = "110100010"` 中，由 `1` 组成的最长连续子字符串的长度是 `2`，由 `0` 组成的最长连续子字符串的长度是 `3`。

注意，如果字符串中不存在 `0`，此时认为由 `0` 组成的最长连续子字符串的长度是 `0`。字符串中不存在 `1` 的情况也适用此规则。

---

示例 1：

```txt
输入：s = "1101"
输出：true

解释：
由 1 组成的最长连续子字符串的长度是 2："1101"
由 0 组成的最长连续子字符串的长度是 1："1101"
由 1 组成的子字符串更长，故返回 true。
```

---

示例 2：

```txt
输入：s = "111000"
输出：false

解释：
由 1 组成的最长连续子字符串的长度是 3："111000"
由 0 组成的最长连续子字符串的长度是 3："111000"
由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false。
```

---

示例 3：

```txt
输入：s = "110100010"
输出：false

解释：
由 1 组成的最长连续子字符串的长度是 2："110100010"
由 0 组成的最长连续子字符串的长度是 3："110100010"
由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false。
```

---

提示：

- `1 <= s.length <= 100`
- `s[i]` 不是 `'0'` 就是 `'1'`

## 2. 🎯 s.1 - 暴力解法

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(N)$，其中 N 是字符串 s 的长度，需要遍历一次字符串
- 空间复杂度：$O(1)$，只使用常数额外空间

算法思路：

- 维护四个变量：当前连续 1 的长度 cur1、当前连续 0 的长度 cur0、最长连续 1 的长度 best1、最长连续 0 的长度 best0
- 遍历字符串，根据当前字符更新连续长度：遇到 '1' 时 cur1 加 1 并重置 cur0 为 0，遇到 '0' 时 cur0 加 1 并重置 cur1 为 0
- 每次遍历后更新最大值 best1 和 best0
- 最后比较 best1 是否严格大于 best0
