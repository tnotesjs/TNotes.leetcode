# [3030. 找出网格的区域平均强度【中等】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3030.%20%E6%89%BE%E5%87%BA%E7%BD%91%E6%A0%BC%E7%9A%84%E5%8C%BA%E5%9F%9F%E5%B9%B3%E5%9D%87%E5%BC%BA%E5%BA%A6%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/find-the-grid-of-region-average/)

给你一个下标从 **0** 开始、大小为 `m x n` 的网格 `image` ，表示一个灰度图像，其中 `image[i][j]` 表示在范围 `[0..255]` 内的某个像素强度。另给你一个 **非负** 整数 `threshold` 。

如果 `image[a][b]` 和 `image[c][d]` 满足 `|a - c| + |b - d| == 1` ，则称这两个像素是 **相邻像素** 。

**区域** 是一个 `3 x 3` 的子网格，且满足区域中任意两个 **相邻** 像素之间，像素强度的 **绝对差** **小于或等于** `threshold` 。

**区域** 内的所有像素都认为属于该区域，而一个像素 **可以** 属于 **多个** 区域。

你需要计算一个下标从 **0** 开始、大小为 `m x n` 的网格 `result` ，其中 `result[i][j]` 是 `image[i][j]` 所属区域的 **平均** 强度，**向下取整** 到最接近的整数。如果 `image[i][j]` 属于多个区域，`result[i][j]` 是这些区域的 **“取整后的平均强度”** 的 **平均值**，也 **向下取整** 到最接近的整数。如果 `image[i][j]` 不属于任何区域，则 `result[i][j]` **等于** `image[i][j]` 。

返回网格 `result` 。

---

- **示例 1：**

![图 0](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-28-21-45-25.png)

```txt
输入：image = [[5,6,7,10],[8,9,10,10],[11,12,13,10]], threshold = 3
输出：[[9,9,9,9],[9,9,9,9],[9,9,9,9]]

解释：
图像中存在两个区域，如图片中的阴影区域所示。
第一个区域的平均强度为 9 ，而第二个区域的平均强度为 9.67 ，向下取整为 9 。
两个区域的平均强度为 (9 + 9) / 2 = 9 。
由于所有像素都属于区域 1 、区域 2 或两者，因此 result 中每个像素的强度都为 9 。
注意，在计算多个区域的平均值时使用了向下取整的值，因此使用区域 2 的平均强度 9 来进行计算，而不是 9.67 。
```

---

- **示例 2：**

![图 1](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-28-21-45-33.png)

```txt
输入：image = [[10,20,30],[15,25,35],[20,30,40],[25,35,45]], threshold = 12
输出：[[25,25,25],[27,27,27],[27,27,27],[30,30,30]]

解释：
图像中存在两个区域，如图片中的阴影区域所示。
第一个区域的平均强度为 25 ，而第二个区域的平均强度为 30 。
两个区域的平均强度为 (25 + 30) / 2 = 27.5 ，向下取整为 27 。
图像中第 0 行的所有像素属于区域 1 ，因此 result 中第 0 行的所有像素为 25 。
同理，result 中第 3 行的所有像素为 30 。
图像中第 1 行和第 2 行的像素属于区域 1 和区域 2 ，因此它们在 result 中的值为 27 。
```

---

- **示例 3：**

```txt
输入：image = [[5,6,7],[8,9,10],[11,12,13]], threshold = 1
输出：[[5,6,7],[8,9,10],[11,12,13]]

解释：
图像中不存在任何区域，因此对于所有像素，result[i][j] == image[i][j] 。
```

---

**提示：**

- `3 <= n, m <= 500`
- `0 <= image[i][j] <= 255`
- `0 <= threshold <= 255`

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
