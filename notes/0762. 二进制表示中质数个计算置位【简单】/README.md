# [0762. 二进制表示中质数个计算置位【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/0762.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E8%B4%A8%E6%95%B0%E4%B8%AA%E8%AE%A1%E7%AE%97%E7%BD%AE%E4%BD%8D%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 位运算 + 质数判断](#2--s1---位运算--质数判断)
- [3. 🎯 s.2 - 字符串操作 + 有效质数集合](#3--s2---字符串操作--有效质数集合)
- [4. 🎯 s.3 - 使用 Brian Kernighan 算法优化计算置位位数](#4--s3---使用-brian-kernighan-算法优化计算置位位数)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/prime-number-of-set-bits-in-binary-representation/)

---

- 给你两个整数 `left` 和 `right` ，在闭区间 `[left, right]` 范围内，统计并返回 **计算置位位数为质数** 的整数个数。
- **计算置位位数** 就是二进制表示中 `1` 的个数。
- 例如， `21` 的二进制表示 `10101` 有 `3` 个计算置位。

---

- **示例 1：**

```txt
输入：left = 6, right = 10
输出：4
解释：
6 -> 110 (2 个计算置位，2 是质数)
7 -> 111 (3 个计算置位，3 是质数)
9 -> 1001 (2 个计算置位，2 是质数)
10-> 1010 (2 个计算置位，2 是质数)
共计 4 个计算置位为质数的数字。
```

- **示例 2：**

```txt
输入：left = 10, right = 15
输出：5
解释：
10 -> 1010 (2 个计算置位, 2 是质数)
11 -> 1011 (3 个计算置位, 3 是质数)
12 -> 1100 (2 个计算置位, 2 是质数)
13 -> 1101 (3 个计算置位, 3 是质数)
14 -> 1110 (3 个计算置位, 3 是质数)
15 -> 1111 (4 个计算置位, 4 不是质数)
共计 5 个计算置位为质数的数字。
```

---

**提示：**

- `1 <= left <= right <= 10^6`
- `0 <= right - left <= 10^4`

## 2. 🎯 s.1 - 位运算 + 质数判断

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(n)$，n 为输入区间的整数个数。
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 字符串操作 + 有效质数集合

::: code-group

<<< ./solutions/2/1.js [1.js]

<<< ./solutions/2/2.js [2.js]

:::

- 时间复杂度：$O(n)$，其中 $n = right - left + 1$
- 空间复杂度：$O(1)$
- 知识点：
  - JS 中的数字类型，在参与位运算的时候，会自动地隐式转换为 32 位。
  - 相关笔记见 `TNotes.javascript - 0129. Number 类型的取值范围【扩展】`
- 提示中提到的范围是 10^6，实际上 2^20 就大于 10^6 了，其实集合也没必要考虑到 32 位，只需要到 20 位就行了。因此使用 `2.js` 提交也能通过。

## 4. 🎯 s.3 - 使用 Brian Kernighan 算法优化计算置位位数

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(n)$，其中 $n = right - left + 1$
- 空间复杂度：$O(1)$
