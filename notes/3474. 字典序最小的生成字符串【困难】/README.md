# [3474. 字典序最小的生成字符串【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3474.%20%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/lexicographically-smallest-generated-string/)

给你两个字符串，`str1` 和 `str2`，其长度分别为 `n` 和 `m` 。

如果一个长度为 `n + m - 1` 的字符串 `word` 的每个下标 `0 <= i <= n - 1` 都满足以下条件，则称其由 `str1` 和 `str2` **生成**：

- 如果 `str1[i] == 'T'`，则长度为 `m` 的 **子字符串**（从下标 `i` 开始）与 `str2` 相等，即 `word[i..(i + m - 1)] == str2`。
- 如果 `str1[i] == 'F'`，则长度为 `m` 的 **子字符串**（从下标 `i` 开始）与 `str2` 不相等，即 `word[i..(i + m - 1)] != str2`。

返回可以由 `str1` 和 `str2` **生成** 的 **字典序最小** 的字符串。如果不存在满足条件的字符串，返回空字符串 `""`。

如果字符串 `a` 在第一个不同字符的位置上比字符串 `b` 的对应字符在字母表中更靠前，则称字符串 `a` 的 **字典序 小于** 字符串 `b`。  
如果前 `min(a.length, b.length)` 个字符都相同，则较短的字符串字典序更小。

**子字符串** 是字符串中的一个连续、**非空** 的字符序列。

---

- **示例 1：**

**输入:** str1 = "TFTF", str2 = "ab"

**输出:** "ababa"

**解释:**

下表展示了字符串 `"ababa"` 的生成过程：

![图 0](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-29-22-31-51.png)

字符串 `"ababa"` 和 `"ababb"` 都可以由 `str1` 和 `str2` 生成。

返回 `"ababa"`，因为它的字典序更小。

---

- **示例 2：**

**输入:** str1 = "TFTF", str2 = "abc"

**输出:** ""

**解释:**

无法生成满足条件的字符串。

---

- **示例 3：**

**输入:** str1 = "F", str2 = "d"

**输出:** "a"

---

**提示:**

- `1 <= n == str1.length <= 10^4`
- `1 <= m == str2.length <= 500`
- `str1` 仅由 `'T'` 或 `'F'` 组成。
- `str2` 仅由小写英文字母组成。

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
