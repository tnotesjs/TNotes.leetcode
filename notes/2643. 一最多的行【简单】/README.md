# [2643. 一最多的行【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/2643.%20%E4%B8%80%E6%9C%80%E5%A4%9A%E7%9A%84%E8%A1%8C%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 遍历统计](#2--s1---遍历统计)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/row-with-maximum-ones/)

给你一个大小为 `m x n` 的二进制矩阵 `mat`，请你找出包含最多 1 的行的下标（从 0 开始）以及这一行中 1 的数目。

如果有多行包含最多的 1，只需要选择行下标最小的那一行。

返回一个由行下标和该行中 1 的数量组成的数组。

---

示例 1：

```txt
输入：mat = [[0,1],[1,0]]
输出：[0,1]

解释：
两行中 1 的数量相同。
所以返回下标最小的行，下标为 0。
该行 1 的数量为 1。所以，答案为 [0,1]。
```

---

示例 2：

```txt
输入：mat = [[0,0,0],[0,1,1]]
输出：[1,2]

解释：
下标为 1 的行中 1 的数量最多。
该行 1 的数量为 2。所以，答案为 [1,2]。
```

---

示例 3：

```txt
输入：mat = [[0,0],[1,1],[0,0]]
输出：[1,2]

解释：
下标为 1 的行中 1 的数量最多。
该行 1 的数量为 2。所以，答案为 [1,2]。
```

---

提示：

- `m == mat.length`
- `n == mat[i].length`
- `1 <= m, n <= 100`
- `mat[i][j]` 为 `0` 或 `1`

## 2. 🎯 s.1 - 遍历统计

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(M \times N)$，其中 M 和 N 分别是矩阵的行数和列数
- 空间复杂度：$O(1)$，只使用常数额外空间

算法思路：

- 遍历矩阵的每一行
- 对每一行统计1的数量（使用 reduce 累加）
- 维护最大1数量及其对应的行下标
- 只有当当前行的1数量严格大于之前的最大值时才更新，这样可以保证在数量相同时选择下标最小的行
- 返回 [行下标, 1的数量]
