# [1122. 数组的相对排序【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/1122.%20%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 计数法（按序输出 + 升序剩余）](#2--s1---计数法按序输出--升序剩余)
- [3. 🎯 s.2 - 排序比较器（rank 映射 + 自定义排序）](#3--s2---排序比较器rank-映射--自定义排序)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/relative-sort-array/)

给你两个数组，`arr1` 和 `arr2`，`arr2` 中的元素各不相同，`arr2` 中的每个元素都出现在 `arr1` 中。

对 `arr1` 中的元素进行排序，使 `arr1` 中项的相对顺序和 `arr2` 中的相对顺序相同。未在 `arr2` 中出现过的元素需要按照升序放在 `arr1` 的末尾。

---

- 示例 1：

```txt
输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
输出：[2,2,2,1,4,3,3,9,6,7,19]
```

- 示例 2：

```txt
输入：arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
输出：[22,28,8,6,17,44]
```

---

提示：

- `1 <= arr1.length, arr2.length <= 1000`
- `0 <= arr1[i], arr2[i] <= 1000`
- `arr2` 中的元素 `arr2[i]` 各不相同
- `arr2` 中的每个元素 `arr2[i]` 都出现在 `arr1` 中

## 2. 🎯 s.1 - 计数法（按序输出 + 升序剩余）

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(n + K)$，其中 $K = 1001$
- 空间复杂度：$O(K)$

解题思路：

- 统计 `arr1` 每个值的频次，值域固定为 0–1000
- 先按 `arr2` 的顺序输出对应元素，再按值域升序输出剩余元素
- 线性时间覆盖所有元素，避免比较器排序

## 3. 🎯 s.2 - 排序比较器（rank 映射 + 自定义排序）

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(n\log n)$
- 空间复杂度：$O(m)$，其中 $m$ 为 `arr2` 长度

解题思路：

- 用哈希映射为 `arr2` 中每个值分配排名 `rank`
- 自定义比较器：两值均在 `arr2` 中按 `rank` 排序，否则按数值升序
- 直接对 `arr1` 排序，代码简洁但需要比较排序
