# [1923. 最长公共子路径【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/1923.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E8%B7%AF%E5%BE%84%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/longest-common-subpath/)

一个国家由 `n`  个编号为 `0`  到 `n - 1`  的城市组成。在这个国家里，**每两个**  城市之间都有一条道路连接。

总共有 `m`  个编号为 `0`  到 `m - 1`  的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。同一个城市在一条路径中可能 **重复** 出现，但同一个城市在一条路径中不会连续出现。

给你一个整数  `n`  和二维数组  `paths` ，其中  `paths[i]`  是一个整数数组，表示第 `i`  个朋友走过的路径，请你返回 **每一个**  朋友都走过的 **最长公共子路径**  的长度，如果不存在公共子路径，请你返回 `0` 。

一个 **子路径** 指的是一条路径中连续的城市序列。

---

- **示例 1：**

```txt
输入：n = 5, paths = [[0,1,2,3,4],
                     [2,3,4],
                     [4,0,1,2,3]]
输出：2
解释：最长公共子路径为 [2,3] 。
```

- **示例 2：**

```txt
输入：n = 3, paths = [[0],[1],[2]]
输出：0
解释：三条路径没有公共子路径。
```

- **示例 3：**

```txt
输入：n = 5, paths = [[0,1,2,3,4],
                     [4,3,2,1,0]]
输出：1
解释：最长公共子路径为 [0]，[1]，[2]，[3] 和 [4] 。它们长度都为 1 。
```

---

**提示：**

- `1 <= n <= 10^5`
- `m == paths.length`
- `2 <= m <= 10^5`
- `sum(paths[i].length) <= 10^5`
- `0 <= paths[i][j] < n`
- `paths[i]`  中同一个城市不会连续重复出现。

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 3. 🎯 s.2 - 解法 2

::: code-group

<<< ./solutions/2/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

## 4. 🎯 s.3 - 解法 3

::: code-group

<<< ./solutions/3/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
