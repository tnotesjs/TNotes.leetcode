# [1923. 最长公共子路径【困难】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/1923.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E8%B7%AF%E5%BE%84%E3%80%90%E5%9B%B0%E9%9A%BE%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)
- [3. 🎯 s.2 - 解法 2](#3--s2---解法-2)
- [4. 🎯 s.3 - 解法 3](#4--s3---解法-3)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/longest-common-subpath/)

一个国家由 `n` 个编号为 `0` 到 `n - 1` 的城市组成。在这个国家里，每两个 城市之间都有一条道路连接。

总共有 `m` 个编号为 `0` 到 `m - 1` 的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。同一个城市在一条路径中可能 重复 出现，但同一个城市在一条路径中不会连续出现。

给你一个整数 `n` 和二维数组 `paths` ，其中 `paths[i]` 是一个整数数组，表示第 `i` 个朋友走过的路径，请你返回 每一个 朋友都走过的 最长公共子路径 的长度，如果不存在公共子路径，请你返回 `0`。

一个 子路径 指的是一条路径中连续的城市序列。

---

- 示例 1：

```txt
输入：n = 5, paths = [[0,1,2,3,4],
                     [2,3,4],
                     [4,0,1,2,3]]
输出：2
解释：最长公共子路径为 [2,3]。
```

- 示例 2：

```txt
输入：n = 3, paths = [[0],[1],[2]]
输出：0
解释：三条路径没有公共子路径。
```

- 示例 3：

```txt
输入：n = 5, paths = [[0,1,2,3,4],
                     [4,3,2,1,0]]
输出：1
解释：最长公共子路径为 [0]，[1]，[2]，[3] 和 [4]。它们长度都为 1。
```

---

提示：

- `1 <= n <= 10^5`
- `m == paths.length`
- `2 <= m <= 10^5`
- `sum(paths[i].length) <= 10^5`
- `0 <= paths[i][j] < n`
- `paths[i]` 中同一个城市不会连续重复出现。

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
