# [3216. 交换后字典序最小的字符串【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3216.%20%E4%BA%A4%E6%8D%A2%E5%90%8E%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 贪心](#2--s1---贪心)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/lexicographically-smallest-string-after-a-swap/)

给你一个仅由数字组成的字符串 `s`，在最多交换一次 相邻 且具有相同 奇偶性 的数字后，返回可以得到的字典序最小的字符串。

> - 字典序更小
> - 在字符串 a 和字符串 b 出现第一个不同的位置，如果字符串 a 有一个字母比字符串 b 中的对应字母在字母表中更早出现，则字符串 a 在字典序上小于字符串 b。
> - 如果前 min(a.length, b.length) 个字符没有不同，则较短的字符串在字段序上较小。

如果两个数字都是奇数或都是偶数，则它们具有相同的奇偶性。例如，5 和 9、2 和 4 奇偶性相同，而 6 和 9 奇偶性不同。

---

示例 1：

输入： s = "45320"

输出： "43520"

解释：

`s[1] == '5'` 和 `s[2] == '3'` 都具有相同的奇偶性，交换它们可以得到字典序最小的字符串。

---

示例 2：

输入： s = "001"

输出： "001"

解释：

无需进行交换，因为 `s` 已经是字典序最小的。

---

提示：

- `2 <= s.length <= 100`
- `s` 仅由数字组成。

## 2. 🎯 s.1 - 贪心

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(n)$，其中 n 是字符串长度
- 空间复杂度：$O(n)$，存储字符数组

算法思路：

- 要使字典序最小，应尽早在高位进行有利的交换
- 从左到右遍历，找到第一对奇偶性相同且前者大于后者的相邻数字
- 交换这对数字后立即返回（最多交换一次）
