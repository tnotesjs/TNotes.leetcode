# [2044. 统计按位或能得到最大值的子集数目【中等】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/2044.%20%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 解法 1](#2--s1---解法-1)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/count-number-of-maximum-bitwise-or-subsets/)

给你一个整数数组 `nums` ，请你找出 `nums` 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目。

如果数组 `a` 可以由数组 `b` 删除一些元素（或不删除）得到，则认为数组 `a` 是数组 `b` 的一个 子集。如果选中的元素下标位置不一样，则认为两个子集 不同。

对数组 `a` 执行 按位或 ，结果等于 `a[0] OR a[1] OR ... OR a[a.length - 1]`（下标从 0 开始）。

---

- 示例 1：

```txt
输入：nums = [3,1]
输出：2
解释：子集按位或能得到的最大值是 3。有 2 个子集按位或可以得到 3 ：
- [3]
- [3,1]
```

- 示例 2：

```txt
输入：nums = [2,2,2]
输出：7
解释：[2,2,2] 的所有非空子集的按位或都可以得到 2。总共有 23 - 1 = 7 个子集。
```

- 示例 3：

```txt
输入：nums = [3,2,1,5]
输出：6
解释：子集按位或可能的最大值是 7。有 6 个子集按位或可以得到 7 ：
- [3,5]
- [3,1,5]
- [3,2,5]
- [3,2,1,5]
- [2,5]
- [2,1,5]
```

---

提示：

- `1 <= nums.length <= 16`
- `1 <= nums[i] <= 10^5`

## 2. 🎯 s.1 - 解法 1

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$
