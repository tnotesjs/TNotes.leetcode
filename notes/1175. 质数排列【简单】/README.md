# [1175. 质数排列【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/1175.%20%E8%B4%A8%E6%95%B0%E6%8E%92%E5%88%97%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 质数计数与排列组合](#2--s1---质数计数与排列组合)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/prime-arrangements/)

请你帮忙给从 `1` 到 `n` 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。

让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。

由于答案可能会很大，所以请你返回答案模 mod `10^9 + 7` 之后的结果即可。

---

示例 1：

```txt
输入：n = 5
输出：12

解释：
举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，
因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。
```

---

示例 2：

```txt
输入：n = 100
输出：682289015
```

---

提示：

- `1 <= n <= 100`

## 2. 🎯 s.1 - 质数计数与排列组合

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(n \sqrt{n})$，其中 $n \le 100$，需遍历寻找质数并计算阶乘
- 空间复杂度：$O(1)$，仅使用了常数空间（不计入 BigInt 存储空间）

算法思路：

- 首先统计 $1$ 到 $n$ 之间的质数个数 `primeCount`
- 质数必须放在质数索引上，其排列方案数为 `primeCount!`
- 非质数放在剩余位置上，其排列方案数为 `(n - primeCount)!`
- 最终结果为两部分排列数的乘积，注意使用 `BigInt` 处理大数溢出并取模

计算公式：

$$
\text{ans} = (\text{primeCount}!) \times ( (n - \text{primeCount})! ) \ \text{mod} \ (10^9+7)
$$
