# copilot 行为指南

## 项目背景

- `TNotes.leetcode` 是一个基于 vitepress 搭建的开源的 Leetcode 知识库，在 [tnotes](../.vitepress/tnotes) 中内置的笔记管理的一系列功能，用于记录 Leetcode 的相关例题及解题思路。
- 所有题目记录在 [notes](../notes) 笔记目录下，从 0001 开始到 3000+ 结束，每个目录对应一道 Leetcode 例题。

```txt
0001. 两数之和【简单】
0002. 两数相加【中等】
...
3564. 季节性销售分析【中等】
3606. 优惠券校验器【简单】
```

## 具体笔记目录的结构

随意以一篇笔记 `0160. 相交链表【简单】` 为例：

```bash
0160. 相交链表【简单】
.
├── .tnotes.json
├── assets
│   ├── .excalidraw
│   └── 1.svg
├── README.md
└── solutions
    ├── 1
    │   └── 1.js
    ├── 2
    │   └── 1.js
    └── 3
        └── 1.js
```

上述记录的是一篇规范的笔记结构，其中：

- `0160. 相交链表【简单】` 表示笔记所属的目录的名称
- `.tnotes.json` 表示笔记的配置文件
- `assets` 存放笔记的一些资源文件，比如用于讲解题解而绘制的一些图片资源等
- `README.md` 是笔记的具体内容，包括这道题的题目描述，题解说明等信息
- `solutions` 存放题解的代码文件，每个目录对应一种题解的实现方式，比如 `solutions/1` 表示第一种题解的实现代码，同一思路的代码可以有多种实现方式，文件命名从 1 开始递增，比如 `solutions/1/1.js` 表示第一种思路的第一种实现方式，`solutions/1/2.js` 表示第一种思路的第二种实现方式

## 题解书写规范

- 编号表示第几种题解，比如第 n 种题解：`## 🎯 s.n - 题解名称`
- 编号默认从 1 开始递增，但允许位置变化，比如 2 排到 1 前面
- 题解代码写在 `solutions` 目录中，并通过 vitepress 的 `<<< ./solutions/1/1.js` 导入代码片段和 `code-group` 的语法来嵌入 `solutions` 目录中的题解
- 题解语言：默认采用 JS 作为首选语言
- 题解书写顺序：
  1. 题解的图解说明，通过 `swiper` 语法来引入 assets 目录中的图片资源，或者上传到图床上的图片链接（只读）
  2. 题解代码，通过 `code-group` 语法引入 `solutions` 目录下的题解，并提供核心的必要注释说明
  3. 题解文字说明
     1. 题解时间、空间复杂度的简单分析，都不能超过一句话，示例：
        - `- 时间复杂度：$O(M + N)$，其中 M 和 N 分别是两个链表的长度`
        - `- 空间复杂度：$O(1)$，只使用了常数级别的额外空间`
     2. 算法思路简介，要求表述简洁无废话，只需描述核心步骤即可

## 笔记内容 `README.md` 规范

- 【1】笔记唯一的一级标题（只读，TNotes.leetcode 会自动根据 README.md 所属的目录来生成笔记中这个唯一的一级标题）
- 【2】笔记的目录区域（只读，这是自动生成的内容，TNotes.leetcode 会自动解析笔记的目录结构，更新目录）
- 【3】题目描述区域（只读，从 LeetCode 中爬取的内容）
- 【4】题解区域（可写，具体规范见“题解书写规范”）
- 【5】引用区域（只读，用于引用相关参考资料）

注意：上述提到的内容中，只有区域 4 是可写的，其余都是只读的。

下面是具体的 `README.md` 示例（以 `0523. 连续的子数组和【中等】`、`3000. 对角线最长的矩形的面积【简单】` 为例）：

```md
# [0523. 连续的子数组和【中等】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/0523.%20%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E3%80%90%E4%B8%AD%E7%AD%89%E3%80%91)

<!-- region:toc -->

... 自动生成的目录区域（只读）...

<!-- endregion:toc -->

## 1. 📝 题目描述

... 题目描述内容（只读）...

## 2. 🎯 s.1 - 前缀和 + 哈希表

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(N)$，其中 N 是数组 nums 的长度
- 空间复杂度：$O(\min(N, K))$，哈希表最多存储 $\min(N, K)$ 个不同的余数

算法思路：

题目要求判断是否存在一个长度至少为 2 的连续子数组，其元素和为 k 的倍数，我们可以暴力枚举所有可能的子数组来判定，但更好的做法是通过 [同余定理][1] 来优化判定流程，这样可以避免枚举所有子数组。

核心公式 => 同余定理：

$$
(a - b) \equiv 0 \pmod{k} \iff a \equiv b \pmod{k}
$$

$$
(a - b) \% k == 0 \iff a \% k == b \% k
$$

在本题中，如果前缀和同余：

$$
\begin{cases}
a = prefixSum[i] \text{（当前索引的前缀和）} \\
b = prefixSum[j] \text{（之前某个索引的前缀和）} \\
i > j  \\
\end{cases}
$$

$$
a \% k == b \% k \text{（如果两个前缀和同余）}
$$

$$
\Rightarrow (a - b) \% k == 0 \text{（意味着子数组 nums[j+1...i] 的和是 k 的倍数）}
$$

实现步骤：

- 维护一个哈希表 `map`，记录 `prefixSum % k` 的余数及其第一次出现的下标
- 初始化 `map.set(0, -1)`
  - 将前缀和为 0 的索引设为 -1 的目的是为了处理从下标 0 开始的子数组
  - 即 $sum[0...i] \% k == 0$ 的情况
- 遍历数组，计算当前的前缀和 `prefixSum` 和余数 `remainder`
  - 如果 `remainder` 已经在 `map` 中存在：
    - 取出之前记录的下标 `prevIndex`
    - 如果当前下标 `i` 满足 `i - prevIndex >= 2`，则说明找到了符合条件的子数组，返回 `true`
  - 如果 `remainder` 不在 `map` 中，将其存入 `map.set(remainder, i)`
    - 注意：如果已经存在，不要更新下标，因为我们要找的是最长的或者说尽早出现的下标，以满足长度 >= 2 的条件

## 3. 🔗 引用

- [百度百科 - 同余定理][1]

[1]: https://baike.baidu.com/item/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86/1212360
```

```md
# [3000. 对角线最长的矩形的面积【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/3000.%20%E5%AF%B9%E8%A7%92%E7%BA%BF%E6%9C%80%E9%95%BF%E7%9A%84%E7%9F%A9%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

... 自动生成的目录区域（只读）...

<!-- endregion:toc -->

## 1. 📝 题目描述

... 题目描述内容（只读）...

## 2. 🎯 s.1 - 暴力解法

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(n)$，遍历一次数组
- 空间复杂度：$O(1)$，只使用常数额外空间

算法思路：

- 遍历所有矩形，计算对角线长度的平方（避免开方运算）
- 如果对角线更长，或对角线相等但面积更大，则更新答案
- 对角线长度公式：$\sqrt{l^2 + w^2}$，比较时可用平方代替
```

## 检查清单

- [ ] 所有带有“只读”的，你都不需要修改
- [ ] 时间/空间复杂度要求使用 LaTeX 数学语法
  - 正确：$O(n)$
  - 错误：O(n)
- [ ] 检查时间、空间复杂度的分析结果，确保分析是正确的
