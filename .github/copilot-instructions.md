# copilot 行为指南

## 项目背景

- `TNotes.leetcode` 是一个基于 vitepress 搭建的开源的 Leetcode 知识库，在 [tnotes](../.vitepress/tnotes) 中内置的笔记管理的一系列功能，用于记录 Leetcode 的相关例题及解题思路。
- 所有题目记录在 [notes](../notes) 笔记目录下，从 0001 开始到 3000+ 结束，每个目录对应一道 Leetcode 例题。

```txt
0001. 两数之和【简单】
0002. 两数相加【中等】
...
3564. 季节性销售分析【中等】
3606. 优惠券校验器【简单】
```

## 具体笔记目录的结构

随意以一篇笔记 `0160. 相交链表【简单】` 为例：

```bash
0160. 相交链表【简单】
.
├── .tnotes.json
├── assets
│   ├── .excalidraw
│   └── 1.svg
├── README.md
└── solutions
    ├── 1
    │   └── 1.js
    ├── 2
    │   └── 1.js
    └── 3
        └── 1.js
```

上述记录的是一篇规范的笔记结构，其中：

- `0160. 相交链表【简单】` 表示笔记所属的目录的名称
- `.tnotes.json` 表示笔记的配置文件
- `assets` 存放笔记的一些资源文件，比如用于讲解题解而绘制的一些图片资源等
- `README.md` 是笔记的具体内容，包括这道题的题目描述，题解说明等信息
- `solutions` 存放题解的代码文件，每个目录对应一种题解的实现方式，比如 `solutions/1` 表示第一种题解的实现代码，同一思路的代码可以有多种实现方式，文件命名从 1 开始递增，比如 `solutions/1/1.js` 表示第一种思路的第一种实现方式，`solutions/1/2.js` 表示第一种思路的第二种实现方式

## 题解书写规范

- 编号表示第几种题解，比如第 n 种题解：`## 🎯 s.n - 题解名称`
- 编号默认从 1 开始递增，但允许位置变化，比如 2 排到 1 前面
- 题解代码写在 `solutions` 目录中，并通过 vitepress 的 `<<< ./solutions/1/1.js` 导入代码片段和 `code-group` 的语法来嵌入 `solutions` 目录中的题解
- 题解语言：默认采用 JS 作为首选语言
- 题解书写顺序：
  1. 题解的图解说明，通过 `swiper` 语法来引入 assets 目录中的图片资源，或者上传到图床上的图片链接（只读）
  2. 题解代码，通过 `code-group` 语法引入 `solutions` 目录下的题解，并提供核心的必要注释说明
  3. 题解文字说明
     1. 题解时间、空间复杂度的简单分析，都不能超过一句话，示例：
        - `- 时间复杂度：$O(M + N)$，其中 M 和 N 分别是两个链表的长度`
        - `- 空间复杂度：$O(1)$，只使用了常数级别的额外空间`
     2. 解题思路简介

## 笔记内容 `README.md` 规范

- 【1】笔记唯一的一级标题（只读，TNotes.leetcode 会自动根据 README.md 所属的目录来生成笔记中这个唯一的一级标题）
- 【2】笔记的目录区域（只读，这是自动生成的内容，TNotes.leetcode 会自动解析笔记的目录结构，更新目录）
- 【3】题目描述区域（只读，从 LeetCode 中爬取的内容）
- 【4】题解区域（可写，具体规范见“题解书写规范”）
- 【5】引用区域（只读，用于引用相关参考资料）

注意：上述提到的内容中，只有区域 4 是可写的，其余都是只读的。

下面是具体的 `README.md` 示例：

````md
# [0160. 相交链表【简单】](https://github.com/tnotesjs/TNotes.leetcode/tree/main/notes/0160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%E3%80%90%E7%AE%80%E5%8D%95%E3%80%91)

<!-- region:toc -->

- [1. 📝 题目描述](#1--题目描述)
- [2. 🎯 s.1 - 暴力解法](#2--s1---暴力解法)

<!-- endregion:toc -->

## 1. 📝 题目描述

- [leetcode](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交：

![图 0](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-09-13-27-33.png)

题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。

自定义评测：

评测系统 的输入如下（你设计的程序 不适用 此输入）：

- `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`
- `listA` - 第一个链表
- `listB` - 第二个链表
- `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数
- `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。

---

- 示例 1：

![图 1](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-09-13-29-02.png)

```txt
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。
换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
```

- 示例 2：

![图 2](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-09-13-29-17.png)

```txt
输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

示例 3：

![图 3](https://cdn.jsdelivr.net/gh/tnotesjs/imgs@main/2025-09-09-13-29-44.png)

```txt
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：No intersection
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```

---

提示：

- `listA` 中节点数目为 `m`
- `listB` 中节点数目为 `n`
- `1 <= m, n <= 3 * 10^4`
- `1 <= Node.val <= 10^5`
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA] == listB[skipB]`

进阶： 你能否设计一个时间复杂度 `O(m + n)` 、仅用 `O(1)` 内存的解决方案？

## 2. 🎯 s.1 - 暴力解法

::: swiper

![走相同的路径](./assets/1.svg)

:::

::: code-group

<<< ./solutions/1/1.js [js]

:::

- 时间复杂度：$O(M + N)$，其中 M 和 N 分别是两个链表的长度
- 空间复杂度：$O(1)$，只使用了常数级别的额外空间

解题思路：

- 这道题要求找到两个链表的相交节点。如果两个链表相交，那么从相交节点开始，两个链表的后续节点都是相同的。
- 我们可以使用双指针技巧来解决这个问题，让两个指针分别遍历两个链表，当一个指针到达链表末尾时，让它从另一个链表的头部重新开始。
  - 如果两个链表相交，两个指针会在相交节点相遇
  - 如果两个链表不相交，两个指针会同时到达末尾（null）
````

## 检查清单

- [ ] 所有带有“只读”的，你都不需要修改
- [ ] 时间/空间复杂度要求使用 LaTeX 数学语法
  - 正确：$O(n)$
  - 错误：O(n)
- [ ] 检查时间、空间复杂度的分析结果，确保分析是正确的
